[
  {
    "objectID": "index.html#опис-навчальної-дисципліни",
    "href": "index.html#опис-навчальної-дисципліни",
    "title": "Вступ до програмування в R",
    "section": "Опис навчальної дисципліни",
    "text": "Опис навчальної дисципліни\nНавчальна дисципліна спрямована на вивчення основ практичного застосування популярної мови R для проведення статистичних досліджень в економіці.\nУ процесі вивчення курсу розглядаються теми, що стосуються теоретичних основ та практичної реалізації алгоритмів, завантаження, підготовки та обробки економічних даних.\nМісце навчальної дисципліни у підготовці здобувачів: програмні результати дисципліни використовуються під час вивчення таких навчальних дисциплін: “Алгоритми та структури даних”, “Аналіз даних в R”, “Прикладне математичне моделювання в R”, “Підготовка аналітичних звітів”. Закріплення на практиці здобутих програмних результатів відбувається під час проходження навчальної практики з курсу “Економіко-математичне моделювання”."
  },
  {
    "objectID": "index.html#мета-дисципліни",
    "href": "index.html#мета-дисципліни",
    "title": "Вступ до програмування в R",
    "section": "Мета дисципліни",
    "text": "Мета дисципліни\nМета навчальної дисципліни – формування у студентів теоретичних знань та практичних навичок використання мови програмування R для роботи з даними та базовими структурами мови (типи даних, розгалуження, цикли, функції)."
  },
  {
    "objectID": "index.html#рецензенти",
    "href": "index.html#рецензенти",
    "title": "Вступ до програмування в R",
    "section": "Рецензенти",
    "text": "Рецензенти\nЗовнішній рецензент\nSasha Talavera, Ph. D. in Economics, Professor of Financial Economics at the Department of Economics, Birmingham Business School, University of Birmingham.\nТекст рецензії\nВнутрішній рецензент\nАнатолій Нікітін, доктор фізико-математичних наук, доцент, професор кафедри економіко-математичного моделювання та інформаційних технологій Національного університету “Острозька академія”.\n\nТекст рецензії"
  },
  {
    "objectID": "index.html#підтримка-проєкту",
    "href": "index.html#підтримка-проєкту",
    "title": "Вступ до програмування в R",
    "section": "Підтримка проєкту",
    "text": "Підтримка проєкту\nМатеріали навчального посібника створено у межах проєкту “Підготовка, обробка та ефективне використання даних для наукових досліджень (на основі R)”, що підтримується Європейським союзою за програмою House of Europe."
  },
  {
    "objectID": "index.html#дотримання-принципів-доброчесності",
    "href": "index.html#дотримання-принципів-доброчесності",
    "title": "Вступ до програмування в R",
    "section": "Дотримання принципів доброчесності",
    "text": "Дотримання принципів доброчесності\nВикладач та слухач цього курсу, як очікується, повинні дотримуватися Кодексу академічної доброчесності університету:\n\nбудь-яка робота, подана здобувачем протягом курсу, має бути його власною роботою здобувача; не вдаватися до кроків, що можуть нечесно покращити Ваші результати чи погіршити/покращити результати інших здобувачів;\nякщо буде виявлено ознаки плагіату або іншої недобросовісної академічної поведінки, то студент буде позбавлений можливості отримати передбачені бали за завдання;\nне публікувати у відкритому доступі відповіді на запитання, що використовуються в рамках курсу для оцінювання знань здобувачів;\nпід час фінальних видів контролю необхідно працювати самостійно; не дозволяється говорити або обговорювати, а також не можна копіювати документи, використовувати електронні засоби отримання інформації.\n\nПорушення академічної доброчесності під час виконання контрольних завдань призведе до втрати балів або вживання заходів, які передбачені Кодексу академічної доброчесності НаУОА.\n\n\n\n\n\n\n\nМатеріали курсу створені з використанням ряду технологій та середовищ розробки:\n\nМова R - безкоштована мова програмування для виконання досліджень у сфері статистики, машинного навчання та візуалізацї результатів.\nQuarto Book - система для публікації наукових та технічних текстів з відкритим кодом (R/Python/Julia/Observable).\nJupyterLab - середовище розробки на основі Jupyter Notebook. JupyterLab є розширеним веб-інтерфейсом для роботи з ноутбуками.\nGit/Github - система контролю версій та, відповідно, сервіс для організації зберігання коду, а також публікації статичних сторінок.\nRStudio Desktop - інтегроване середовище розробки (IDE) для мови R з відкритим кодом, що містить в собі редактор коду, консоль, планер, засоби візуалізації та можливості.\nVisual Studio Code - інтегроване середовище розробки (IDE) з відкритим кодом практично для усіх відомих технологій та мов програмування.\n\n\n\n\n\nБібілографічний опис bibtex:\n@book{yk-r-intro,\n  author       = {Юрій Клебан},\n  title        = {Вступ до програмування в R},\n  publisher    = {Zenodo},\n  year         = 2022,\n  doi          = {10.5281/zenodo.7251419},\n  url          = {https://doi.org/10.5281/zenodo.7251419}\n}"
  },
  {
    "objectID": "00-intro.html",
    "href": "00-intro.html",
    "title": "Вступ",
    "section": "",
    "text": "На даний час існує велика кількість мов програмування, що інтегруються у суспільні сфери діяльності людини та роботи технічних систем: біоінформатика, а також економіка та бізнес.\nОднією з мов програмування, що отримали широке поширення серед економістів-науковців, аналітиків та практиків математичного моделювання (machine learning) є мова програмування R(R Core Team 2020). Свою популярність ця мова програмування здобула завдяки простоті у використанні, доступності (безкоштовні як базові компоненти для написання коду, так і середовища розробки), розширюваності (кожен розробник має можливість створювати власні пакети та публікувати їх у відкритому доступі).\nОсновними задачами курсу “Вступ до прикладного програмування в R” є ознайомлення студентів з базовми конструкціями мови програмування R, вивчення способів роботи з найпоширенішими типами даних, читання інформації з різноманітних джерел. Також студенти отримують знання про можливості використання R для виконання задач аналізу даних та візуалізації.\n\n\n\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "01-what-is-r.html",
    "href": "01-what-is-r.html",
    "title": "\n1  Що таке R?\n",
    "section": "",
    "text": "Синтаксис мови програмування R є досить простим для вивчення та використання, а широкий набір готових пакетів дозволяє використати готові розробки для вирішення широкого спектру задач від статистичних обчислень до навчання нейронних мереж для розпізнавання/класифікації зображень.\nВажливо відмітити, що мова програмування R є безкоштовною (free) і має відкритий код (open source).\nR має ряд корисних властивостей:\n\nВізуалізація даних. Побудова різноманітих видів графіків, робота з мапами, широкий спектр бібліотек та налаштувань до них.\nПовторне використання коду. На відміну від електронних таблиць, що мають обмеження на кількість спостережень (наприклад, MS Excel), R дозволяє працювати з великими масивами даних та перезапускати обчислення у потрібний момент, не створюючи додаткових копій даних.\nМашинне навчання. R дозволяє використати для побудови, навчання та тестування моделей, а також оптимізації гіперпараметрів та відбору факторів дуже велику кількість алгоритмів. Існують також спеціальні пакети, що об’єднують у собі усі описані функції та алгоритми, наприклад, caret(Kuhn 2022) та mlr(Lang et al. 2019).\nАвтоматизація. Написаний код та проєкти можна перетворити у готові до публікації та впровадження продукти (deployment) або використовувати напрацьовані алгоритми для швидкого вирішення схожих задач (pipeline).\n\nТакож можна виділити досить корисні можливості R як *розробка веб-застосунків та підготовка звітності**, адже, використовуючи спеціальні бібліотеки (shiny(Chang et al. 2022), shinydashboard(Chang and Borges Ribeiro 2021), flexdashboard(Sievert et al. 2022), rmarkdown(Xie, Dervieux, and Riederer 2020), knitr(Xie 2015) тощо) результати виконаної роботи можна “оживити” або сформувати “на льоту” готові до презентації документи.\n\n\n\n\nChang, Winston, and Barbara Borges Ribeiro. 2021. Shinydashboard: Create Dashboards with ’Shiny’. https://CRAN.R-project.org/package=shinydashboard.\n\n\nChang, Winston, Joe Cheng, JJ Allaire, Carson Sievert, Barret Schloerke, Yihui Xie, Jeff Allen, Jonathan McPherson, Alan Dipert, and Barbara Borges. 2022. Shiny: Web Application Framework for r. https://CRAN.R-project.org/package=shiny.\n\n\nKuhn, Max. 2022. Caret: Classification and Regression Training. https://CRAN.R-project.org/package=caret.\n\n\nLang, Michel, Martin Binder, Jakob Richter, Patrick Schratz, Florian Pfisterer, Stefan Coors, Quay Au, Giuseppe Casalicchio, Lars Kotthoff, and Bernd Bischl. 2019. “mlr3: A Modern Object-Oriented Machine Learning Framework in R.” Journal of Open Source Software, December. https://doi.org/10.21105/joss.01903.\n\n\nSievert, Carson, Richard Iannone, JJ Allaire, and Barbara Borges. 2022. Flexdashboard: R Markdown Format for Flexible Dashboards. https://CRAN.R-project.org/package=flexdashboard.\n\n\nXie, Yihui. 2015. Dynamic Documents with R and Knitr. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://yihui.org/knitr/.\n\n\nXie, Yihui, Christophe Dervieux, and Emily Riederer. 2020. R Markdown Cookbook. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown-cookbook."
  },
  {
    "objectID": "02-r-history.html",
    "href": "02-r-history.html",
    "title": "\n2  Коротка історія мови R\n",
    "section": "",
    "text": "Влітку 1993 року двоє молодих новозеландських вчених анонсували свою нову розробку, яку вони назвали R (є інформація, що буква \"R\" була обрана тому, що вона стоїть перед \"S\" у латинському алфавіті, тут є аналогія з мовою \"C\", якій передувала мова \"B\"). За задумом авторів (Robert Gentelman та Ross Ihaka) це повинна була бути нова реалізація мови S, що відрізнялася від S-Plus деякими деталями, наприклад, роботою з локальними та глобальними змінними, пам’яттю тощо. Фактично було створено нову мову, що відгалуджується від S.\nПроєкт з самого початку розвивався досить повільно, але коли у команди розробників R з’явилися ресурси, зокрема, зручна системи створення розширень (пакетів), все більше аналітиків, статистиків, вчених, програмістів почало переходити з S-Plus на R. Коли були усунуті проблеми роботи з пам’яттю перших версій R, на цю мову почали переходити користувачі інших статистичних пакетів (SAS, Stata, SYSSTAT).\nКількість книг та публікацій у мережі Інтернет по роботі з R постійно зростає разом із зацікавленням молодих і вже досвідчених спеціалістів з різних сфер діяльності, що активно застосовують у роботі науку про дані, машинне навчання, візуалізацію та аналітику тощо."
  },
  {
    "objectID": "03-r-environment.html",
    "href": "03-r-environment.html",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "",
    "text": "R є безкоштовним програмним забезпеченням, що розповсюджується за умовами GNU General Public License. Код, написаний на R компілюється та запускається на різних платформах: UNIX, Windows, MacOS (R Core Team 2020).\nДля завантаження актуальної версії R варто перейти на сайт проекту https://cran.r-project.org/.\nНа сайті обираємо завантаження R для потрібної операційної системи. У межах курсу ми вокристовуємо ОС Windows, проте на синтаксис мови програмування та процес написання коду це не впливає:\n\n\nРис. 3.1. Завантаження R. Вибір ОС\n\n\nУ наступному вікні клікаємо на install R for the first time:\n\n\nРис. 3.2. Завантаження R. Перша інсталяція\n\n\nДалі обираємо Download R 4.X.X for Windows, де 4.X.X версія R, яка може бути відмінною на момент вивчення курсу:\n\n\nРис. 3.3. Завантаження R. Завантаження версії для ОС\n\n\nПісля завантаження файлу інсталяції потрібно його запустити. Зазвичай завантажений файл можна побачити у лівому нижному кутку браузера або у розділі “Завантаження” Вашого браузера. Наприклад, у браузері Google Chrome знайти цей пункт меню так:\n\n\nРис. 3.4. Завантаження R. Розділ \"Завантаження\" у Google Chrome"
  },
  {
    "objectID": "03-r-environment.html#перший-запуск-r-gui",
    "href": "03-r-environment.html#перший-запуск-r-gui",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.2 Перший запуск R GUI\n",
    "text": "3.2 Перший запуск R GUI\n\nЗа замовчуванням під час інсталяції R у ОС Windows пропонується шлях C:\\Program Files\\R\\R-4.X.X.\nДля запуску R GUI (стандартного графічного інтерфейсу для роботи з R) потрібно зайти у папку bin\\x64 (або i386, якщо у Вас 32-х розрядна ОС) та запустити файл Rgui.exe.\nВигляд вікна R GUI зображено нижче:\n\n\nРис. 3.5. Вигляд головного вікна RGui\n\n\n\n\n\n\n\n\nNote\n\n\n\nGUI (Graphical User Interface) - набір візуальних компонентів для інтерактивної взаємодії користувача з програмним забезпеченням.\n\n\nУ вікні R Console можна вводити команди/інструкції R, що будуть виконуватися:\nРезультати виконання команд зберігаються у памяті програми і можуть бути використані у наступних блоках коду:\n\n\nРис. 3.6. Вигляд консолі для команд RGui\n\n\nСередовище R GUI має широкий спектр функцій і дозволяє написати будь-якого рівня складності проекти на R, проте він є лише базовою графічною обгорткою для R. Розглянемо інші зручніші середовища для написання R-коду."
  },
  {
    "objectID": "03-r-environment.html#поняття-робочого-простору",
    "href": "03-r-environment.html#поняття-робочого-простору",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.3 Поняття робочого простору",
    "text": "3.3 Поняття робочого простору\nУ процесі виконання коду створені об’єкти/змінні та функції зберігаються у поточній сесії. У R є можливість переглянути список збережних елментів, видалити усі або окремі, зберегти стан поточної сесії диск та завантажити його пізніше, щоб не проходти усі етапи виконання коду повторно (інколи дуже складний код може виконувати досить довго і збереження проміжних результатів може бути хорошим рішенням).\nДля прикладу створимо дві змінні var1, var2 та виведемо на консоль їх значення:\n\nvar1 <- 10\nvar2 <- sqrt(15)\nvar1\n\n[1] 10\n\nvar2\n\n[1] 3.872983\n\n\nДля того аби переглянути список змінних у поточній сесії варто скористатися ls():\n\nls()\n\n[1] \"var1\" \"var2\"\n\n\nЯкщо виникає потреба очистити робочий простір і звільними пам’ять використовується команда rm(). Так, щоб очистити усі змінні можна скористатися rm(list = ls()), якщо ж Ви хочете видалити якусь одну/дві змінних, то просто вкажіть імена:\n\nrm(list = c(\"var1\"))\nls()\n\n[1] \"var2\"\n\n\nТаким чином, після виконання коду вище, залишиться лише змінна var2.\nЗберігання образу (image) робочого простору на диск здійснюється за допомогою команди save.image(\"шлях до файлу.RData\"), а його зчитування за допомогою load(\"шлях до файлу.RData\").\nКод збереження даних:\n\n# Clear workspace\nrm(list = ls())\n\n# Declare variables\na <- 10\nb <- a + 15\n\n# Save image to file\nsave.image(\"tmp.RData\")\n\nКод читання та виведення даних:\n\n# Clear workspace\nrm(list = ls())\n\n# load image to file\nload(\"tmp.RData\")\n\nprint(a)\n\n[1] 10\n\nprint(b)\n\n[1] 25\n\n\nУ прикладі 2 не створюєть жодного параметра, проте вони збережні у файлі сесії.\nДля того аби зберегти та зчитати окремий об’єкт, а не всі елементи сесії у R є спеціальний формат .RDS, який реалізовується методами saveRDS(об'єкт, file=\"шлях_файлу.rds\") та readRDS(file=\"шлях_файлу.rds\")."
  },
  {
    "objectID": "03-r-environment.html#поняття-робочого-каталогу",
    "href": "03-r-environment.html#поняття-робочого-каталогу",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.4 Поняття робочого каталогу",
    "text": "3.4 Поняття робочого каталогу\nРобота в будь-якому середовищі передбачає зв’язок із поточним каталогом, відносно якого будуються шляхи до файлів. Звичайно можна писати завжди повний шлях до файла, проте такий підхід є досить негнучким і під час перенесення коду між ПК створює чимало проблем розробникам.\nДля визначення базового каталогу R в поточній сесії використовують команду getwd(). Якщо Ви користуєтеся RStudio та створили проєкт, то цей каталог буде відповідати повному шляху до папки проєкту:\n\ngetwd()\n\n[1] \"E:/Repos/OA_2023/intro-to-r-source\"\n\n\nДля того аби змінити поточний робочий каталог використовують команду setwd(шлях). Після запуску цієї команди функцій getwd() буде вказутивати уже на нову адресу/шлях.\n\n\n\n\n\n\nImportant\n\n\n\nВарто знати та вміти будувати абсолютні та відносні шляхи до каталогів та файлів, ці знання корисні для роботи з усіма мовами програмування та більшістю ПЗ для роботи з даними.\n\n\nДля запису шляху у ОС Windows можна скористатися 2-ма способами:\n\n\n/ - слеш, записується як один знак;\n\n\\\\ - бекслеш, записується як два знаки.\n\nУ прикладі нижче обидва шляхи ведуть до тієї ж папки (drive - буква диска):\nsetwd(\"drive:/folder1/folder2/\")\nsetwd(\"drive:\\\\folder1\\\\folder2\\\\\")\nДля перегляду інформації про наявні каталоги та файли у поточній робочій папці можна скористатися командою dir() або list.files():\n\ndir()\n\n [1] \"_language-ua.yml\"            \"_quarto.yml\"                \n [3] \"00-intro.html\"               \"00-intro.qmd\"               \n [5] \"01-what-is-r.html\"           \"01-what-is-r.qmd\"           \n [7] \"02-r-history.html\"           \"02-r-history.qmd\"           \n [9] \"03-r-environment.qmd\"        \"03-r-environment.rmarkdown\" \n[11] \"03-r-environment_files\"      \"04-r-help.qmd\"              \n[13] \"05-r-packages.qmd\"           \"06-r-input-output.qmd\"      \n[15] \"07-r-variables.qmd\"          \"08-r-basic-types.qmd\"       \n[17] \"09-r-operators.qmd\"          \"10-r-conditions-if-else.qmd\"\n[19] \"11-r-loops.qmd\"              \"12-userful-math.qmd\"        \n[21] \"13-r-functions.qmd\"          \"14-r-vectors.qmd\"           \n[23] \"15-r-data.frames.qmd\"        \"16-r-lists.qmd\"             \n[25] \"commands\"                    \"css\"                        \n[27] \"demo.qmd\"                    \"docs\"                       \n[29] \"identity\"                    \"img\"                        \n[31] \"index.html\"                  \"index.log\"                  \n[33] \"index.qmd\"                   \"index.tex\"                  \n[35] \"index_files\"                 \"intro-to-r-source.Rproj\"    \n[37] \"references.bib\"              \"references.qmd\"             \n[39] \"site_libs\"                   \"solved-tasks.qmd\"           \n[41] \"summary.qmd\"                 \"tasks.qmd\"                  \n[43] \"tmp.RData\"                  \n\nlist.files()\n\n [1] \"_language-ua.yml\"            \"_quarto.yml\"                \n [3] \"00-intro.html\"               \"00-intro.qmd\"               \n [5] \"01-what-is-r.html\"           \"01-what-is-r.qmd\"           \n [7] \"02-r-history.html\"           \"02-r-history.qmd\"           \n [9] \"03-r-environment.qmd\"        \"03-r-environment.rmarkdown\" \n[11] \"03-r-environment_files\"      \"04-r-help.qmd\"              \n[13] \"05-r-packages.qmd\"           \"06-r-input-output.qmd\"      \n[15] \"07-r-variables.qmd\"          \"08-r-basic-types.qmd\"       \n[17] \"09-r-operators.qmd\"          \"10-r-conditions-if-else.qmd\"\n[19] \"11-r-loops.qmd\"              \"12-userful-math.qmd\"        \n[21] \"13-r-functions.qmd\"          \"14-r-vectors.qmd\"           \n[23] \"15-r-data.frames.qmd\"        \"16-r-lists.qmd\"             \n[25] \"commands\"                    \"css\"                        \n[27] \"demo.qmd\"                    \"docs\"                       \n[29] \"identity\"                    \"img\"                        \n[31] \"index.html\"                  \"index.log\"                  \n[33] \"index.qmd\"                   \"index.tex\"                  \n[35] \"index_files\"                 \"intro-to-r-source.Rproj\"    \n[37] \"references.bib\"              \"references.qmd\"             \n[39] \"site_libs\"                   \"solved-tasks.qmd\"           \n[41] \"summary.qmd\"                 \"tasks.qmd\"                  \n[43] \"tmp.RData\""
  },
  {
    "objectID": "03-r-environment.html#робота-з-rstudio",
    "href": "03-r-environment.html#робота-з-rstudio",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.5 Робота з RStudio\n",
    "text": "3.5 Робота з RStudio\n\n\n3.5.1 Завантаження та інсталяція RStudio Desktop\n\nRStudio - це інтегроване середовище розробки для R. Воно включає у себе консоль, підсвічування синтаксису (підказки), прямий запуск коду, інструменти для візуалізації графіків, html-коду, історію виконаних команд, відлагоджування коду, управління робочими просторами, підтримка різних видів розмітки та багато іншого. RStudio має версію з відкритим кодом та комерційну версію для Windows, Linux та Mac, а також веб-версію для серверів на Linux RStudio Server та RStudio Server Pro (RStudio Official Website 2021).\n\n\n\n\n\n\nNote\n\n\n\nIDE (integrated development environment) - комплексне програмне рішення для розробки програмного забезпечення. Зазвичай, складається з редактора початкового коду, інструментів для автоматизації складання та відлагодження програм. Більшість сучасних середовищ розробки мають можливість автодоповнення коду. Wikipedia\n\n\nЗавантажити продукти можна з сайту https://rstudio.com. Щоб знайти середовище, яке ми будемо використовувати під час вивчення курсу варто виконати наступні кроки:\n\nУ головному меню сайту обрати Products > RStudio.\nЗнаходимо на сторінці кнопку для завантаження програми RStudio Desktop версії Open Source та натискаємо DOWNLOAD RSTUDIO DESKTOP:\n\n\n\nРис. 3.7. Вибір версії RStudio Desktop\n\n\n\nДалі обираємо завантаження безкоштовної версії RStudio Desktop з наданого переліку:\n\n\n\nРис. 3.8. Завантаження RStudio Desktop\n\n\nПісля завантаження запускаємо інсталятор RStudio. Особливих кроків у цьому процесі немає.\nПісля запуску IDE RStudio зазвичай складається з 3-х або 4-х блоків: * Файл, з яким працювали останнім (зліва зверху). * Консоль для введення коду та виведення результатів (зліва знизу). * Змінні середовища (Environment) (справа зверху) + Історія команд (History), Зєднання з зовнішніми ресурсами даних, наприклад, бази даних (Connections), навчальна інструкція (Tutorial). * Файли каталогу або проекту (Files), Інстальовані пакети (Packages), Допомога (Help), Візуалізація результатів (Plots, Viewer).\n\n\nРис. 3.9. Головне вікно RStudio Desktop\n\n\nДля першої демонстрації роботи виконаємо у консолі 2 рядки коду:\n\n\nРис. 3.10. Приклад написання коду в RStudio Desktop\n\n\nПерший рядок з кодом data <- c(3,7,1,6,3,4,5,4,2) створює у пам’яті колекцію чисел. Зверніть увагу, що у блоці Environments відобраюаться усі змінні, що уснують у поточному робочому просторі (про це буде далі).\nДругий рядок plot(data, type=\"l\") дозволяє побудувати простий лінійний графік (type=\"l\" - linear, \"p\" - point, help(plot) для деталей). Графіки, що “промальовуються” як картинки выдображаються у блоці Plots. Якщо ж графік має більш складну візуалізацію з інтерактивними елементами, що використовують уже засоби html/css/js, то він буде відображений у блоці View.\nЯкщо перемкнутися на вкладку History, то ми побачимо перелік раніше виконаних команд.\n\n\n\n\n\n\nNote\n\n\n\nДля швидкого “гортання” уже виконаних раніше команд на консолі (Console) можна скористатися клавішами Up/Down на клавіатурі: \n\n\n\n3.5.2 Створення першого проекту в RStudio\nНа відміну від R Gui в RStudio реалізовано концепцію проектів, що дозволяє організувати код та поєднати різні його частини у межах певного рішення.\nСтворимо наш перший проект.\nДля початку оберемо з верхнього меню пункт File > New Project. У вікні вибору способу створення проекту клікаємо New Directory. Такий спосіб передбачає, що жодного файлу проекту поки не існує або ми пізніше туди скопіюємо уже готовий код.\n\n\nРис. 3.11. RStudio Desktop. Новий проєкт\n\n\nНа наступному кроці обираємо New Project:\n\n\nРис. 3.12. RStudio Desktop. Новий проєкт. Тип проекту\n\n\nПісля кліку на Create Project буде створено папку за попередньо обраним шляхом. Для запуску проєкту або швидкого перемикання між проектами можна скористатися як пунктами головного меню, так і підменю проектів справа. Також відкрити проект можна запуском файлу *.Rproj у провіднику Windows.\n\n\nРис. 3.13. RStudio Desktop. Новий проєкт\n\n\nЩоб додати новий файл з кодом R потрібно обрати з головного меню File > New file > R Script або скористатися командою Ctrl+Shift+N. Новий файл буде створено з назвою Untitled[X], тому рекомендую одразу його зберегти, наприклад, як TestCode.R\nДля першого проекту розвяжемо наступну задачу:\n\nНаписати програму, що генерує вектор з 20-ти випадкових чисел у межах [1;5], обчислює середнє та суму чисел, а також виводить гістограму частоти кожного значення (скільки разів дане число повторюється у векторі).\n\nКод для генерації 20-ти випадкових чесел у діапазоні [1;5] матиме наступний вигляд:\n\nvtr <- sample(1:5, 20, replace=TRUE)\nvtr\n\n [1] 2 2 3 2 1 3 3 3 3 3 3 1 1 4 1 2 5 2 3 2\n\n\n\n\n\n\n\n\nImportant\n\n\n\nРезультати виконання на Вашому ПК будуть іншими, адже псевдогенератор випадкових чисел буде брати іншу “точку відліку” для генерування чисел. Рекомендую перегляду функцію set.seed(точка відліку - число).\n\n\nОбчислення та виведення на консоль інформації про суму та середнє значення:\n\nvtr_sum <- sum(vtr)\nvtr_mean <- mean(vtr)\n\nprint(paste0(\"Sum: \", vtr_sum))\n\n[1] \"Sum: 49\"\n\nprint(paste0(\"Mean: \", vtr_mean))\n\n[1] \"Mean: 2.45\"\n\n\nВиведемо гістограму:\n\nhist(vtr, breaks = 5)\n\n\n\nРис. 3.14. Приклад візуалізації гістрограми в R\n\n\n\n\nПримітка. Детальніше про параметри функції hist() можна почитати тут: https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/hist.\nОрієнтовний вигляд вікна RStudio після викоання усіх описаних вище операцій матиме настпуний вигляд:\n\n\nРис. 3.15. RStudio Desktop. Перегляд змінних\n\n\nВарто звернути увагу на виділений блок Environment, де можна переглянути усі доступні змінні, що є на даний момент у пам'яті. До цих параметрів можна звертатися у коді чи з консолі у будь, який момент. Детальну інформацію про робоче середовище розглянуто нижче."
  },
  {
    "objectID": "03-r-environment.html#робота-з-jupyter-notebook",
    "href": "03-r-environment.html#робота-з-jupyter-notebook",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.6 Робота з Jupyter Notebook\n",
    "text": "3.6 Робота з Jupyter Notebook\n\nНоутбуки стали зручним та поширеним інструментом для аналізу даних, а також послідовного викладення матеріалів чи результатів дослідження. Перевагою такого інструменту є перемішування коду, результатів його виконання та іншого текстового наповнення, що дозволяє сформувати “на льоту” готові до читання документи.\nВикористання ноутбуків у навчальному процесі дозволяє описати не лише теоретичний матеріал, але приклади коду, що будуть виконувати безпосередньо під час ознайомлення з лекцією. Також слухач курсу може відредагувати наявний код та перевірити результати його виконання.\nРозгялнемо процес інсталяції та запуску Anaconda (середовище з відкритим кодом для вирішення задач Data Science) та Jupyter Notebook на ПК.\nДля встановлення середовища Anaconda потрібно перейти на сайт проекту та завантажити індивідуальну версію продукту: https://www.anaconda.com/products/individual (Anaconda. The World’s Most Popular Data Science Platform 2021).\n_*Примітка. Усі операції у даному курсі виконуються під операційну систему Windows 11 Education Edition_.\nПроцес інсталяції середовища Anaconda не відрізняється від стандарного покрокового вставнолення програм у Windows.\nПісля запуску Anaconda Navigator для початку потрібно створити нове середовище та налаштувати роботу R:\n\n\nРис. 3.16. Anaconda Navigator\n\n\nДля початку потрібно перейти на вкладку Environments та натиснути Create:\n\n\nРис. 3.17. Головне вікно Anaconda Navigator\n\n\nУ вікні, що відкрилося потрібно відмітити [x] вставновлення інструментів для роботи з R:\n\n\nРис. 3.18. Створення нового середовища на основі R у Anaconda Navigator\n\n\nПісля встановлення R-інструментів оптрібно переключитися на вкладку Home та робочий простір:\n\n\nРис. 3.19. Зміна середовища у Anaconda Navigator\n\n\nПісля завантаження робочого простору оберіть Launch для запуску Jupyter Notebook з переліку встановлених засобів. Jupyter Notebook буде запущено у браузері за замовчеванням Вашого ПК. Відкрити ноутбук можна обравши потрібний файл, а створити новий у меню справа New > Notebook > R:\n\n\nРис. 3.20. Створення нового Jupyter Notebook"
  },
  {
    "objectID": "03-r-environment.html#огляд-додаткових-ide-та-сервісів-для-роботи-з-r",
    "href": "03-r-environment.html#огляд-додаткових-ide-та-сервісів-для-роботи-з-r",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.7 Огляд додаткових IDE та сервісів для роботи з R",
    "text": "3.7 Огляд додаткових IDE та сервісів для роботи з R\nОкрім середовищ описаних вище існує ряд досить цікавих інструментів, що роблять досить зручною роботу з R-кодом. Розглянемо ці інструменти.\nVisual Studio Code - безкоштовний редактор коду від Microsoft, орієнтовний на велику кількість мов програмування та фреймворків (Visual Studio Code 2021). Серед інших іструментів у VS Code доступні також розширення для роботи з R:\n\n\nРис. 3.21. Вікно середовища Visual Studio Code\n\n\nVisual Studio Community Edition - безкоштовне середовище розробки від компаній Microsoft. VS створено з самого початку для розробки під платформу .NET та мови програмування C#, VB.NET, F# тощо, але з часом отримало багато розширень, що дозволяють у тому числі, працювати і з проектами в R (Visual Studio Community Edition 2021).\nGoogle Collab - онлайн сервіс для роботи з ноутбуками для Data Science від компанії Google (Google Colaboratory 2021):\n\n\nРис. 3.22. Вікно середовища Google Collab\n\n\nПримітка. Код у прикладі вище написаний на Python.\nkaggle.com - сервіс для змагань з Data Science та Machine Learning. Окрім переліку змагань, наборів даних сервіс має досить зручні ноутбуки.\n\n\nРис. 3.23. kaggle.com\n\n\nЗагалом сервісів та середовищ для розробки в R існує досить багато і їх кількість зростає, але це не впливає на принципи написання коду та роботу з даними.\n\n\n\n\nAnaconda. The World’s Most Popular Data Science Platform. 2021. 206 379 Broadway Ave., Suite 310 New York, NY 10013, USA: Anaconda Inc. https://www.anaconda.com/.\n\n\nGoogle Colaboratory. 2021. Google LLC. https://colab.research.google.com/.\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nRStudio Official Website. 2021. 250 Northern Ave, Boston, MA 02210: RStudio, PBC. https://rstudio.com/.\n\n\nVisual Studio Code. 2021. Microsoft. https://code.visualstudio.com/.\n\n\nVisual Studio Community Edition. 2021. Microsoft. https://visualstudio.microsoft.com/."
  },
  {
    "objectID": "04-r-help.html",
    "href": "04-r-help.html",
    "title": "\n4  Документація та допомога\n",
    "section": "",
    "text": "# Get help for intersect() function\nhelp(intersect)\nЯкщо є потреба отримати інформацію про пакет скористайтеся:\nhelp(package = \"stats\")\n\n\n\n\n\n\nNote\n\n\n\nДетальну документацію по роботі з пакетами Ви можете знайти тут:\n\nhttps://cran.r-project.org/web/packages/available_packages_by_name.html\nhttps://www.rdocumentation.org/\nhttps://rdrr.io/r/\n\n\n\nРозглянемо для прикладу візуалізацію інформації про функцію mean(), що використовується для знаходження середнього значення:\nhelp(mean)\n\n\nРис. 4.1. Скріншот інформації про функцію mean() з пакету base(R Core Team (2020))\n\n\nОтримана інформація дозволить визначити як правильно викликати функцію, які параметри вона приймає та що вони означають. Наявність прикладів виклику функції такод полегшить роботу з написання коду.\n\n\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "05-r-packages.html",
    "href": "05-r-packages.html",
    "title": "\n5  Робота з пакетами\n",
    "section": "",
    "text": "Своєю популярністю R завдячує, у тому числі, і можливості швидко реалізувати досить складні дослідження за допомогою наборів уже готових функції. Такі функції обєднуються у пакети та публікуються вченими, досліджниками та розробниками зі всього світу.\nПакети в R - організовані набори методів та класів для виконання вузького набору задач під час програмування на R. Вони містять як функції так і опис способів їх використання, а чтакож дані для відтворення прикладів коду.\nПакети можуть бути завантажені з офіційного сайту проекту cran.r-project.org / (R Core Team 2020) або інших джерел (dev-версії є доступні на github).\nЗавантаження пакетів у R можна здійснювати як з локального диска, так і з серверів у мережі Інтернет.\nДля встановлення пакету використовується команда install.packages():\ninstall.packages(\"fun\")\nДля підключення пакету та його використання варто скористатися функцією library():\npackageDescription(\"fun\")\nhelp(package = \"fun\")\n\n\n\n\n\n\nNote\n\n\n\nДуже рекомендую почитати детальніше про пакети у статті на DataCamp: R Packages: A Beginner’s Guide."
  },
  {
    "objectID": "05-r-packages.html#робота-з-пакетами-в-rstudio",
    "href": "05-r-packages.html#робота-з-пакетами-в-rstudio",
    "title": "\n5  Робота з пакетами\n",
    "section": "\n5.2 Робота з пакетами в RStudio\n",
    "text": "5.2 Робота з пакетами в RStudio\n\nРобота з пакетами в RStudio організована досить зручно і дозволяє швидко переглянути інформацію про пакет та функції, які він дозволяє використати.\nДля інсталяції та оновлення пакетів можна скористатися меню Tools:\n\n\nРис. 5.1. Меню інсталяції пакетів у RStudio Desktop\n\n\nПісля вибору Install Packages... відкриється вікно, де можна обрати як джерело інсталяції пакету так і сам пакет з переліку, ввівши кілька перших букв його назви:\n\n\nРис. 5.2. Вибір пакету для інсталяції у RStudio Desktop\n\n\nRStudio дозволяє також переглянути інстальовані пакети/бібліотеки, розроблені іншими користувачами та завантажені у пам’ять (“галочка” навпроти назви пакету):\n\n\nРис. 5.3. Перегляд інстальованих пакетів у RStudio Desktop\n\n\nДоступ до функцій та інших елементів пакету можна здійснювати використавши запис назва_пакету::назва_функції() без підключення бібліотеки за допомогою library():\n\n\nРис. 5.4. Приклад використання пакету fun у RStudio Desktop\n\n\nКористувачі можуть не тільки завантажувати існуючі пакети, але і створювати власні та роботи їх доступними для дослідників зі всього світу."
  },
  {
    "objectID": "05-r-packages.html#завдання-для-студентів",
    "href": "05-r-packages.html#завдання-для-студентів",
    "title": "\n5  Робота з пакетами\n",
    "section": "Завдання для студентів",
    "text": "Завдання для студентів\nВстановіть пакет fun, використовуючи функцію install.packages() та перегляньте його документацію за допомогою help().\nДля прикладу, спробуйте пройти якийсь з тестів.\nНижче наведено приклад роботи з функцією alzheimer_test() з пакету fun:\n\nlibrary(fun)\nalzheimer_test(\n  char1 = c(\"9\", \"O\", \"M\", \"I\", \"F\", \"D\"),\n  char2 = c(\"6\", \"C\", \"N\", \"T\", \"E\", \"O\"),\n  nr = 10,\n  nc = 30))\n\n\n\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "06-r-input-output.html",
    "href": "06-r-input-output.html",
    "title": "\n6  Введення-виведення даних\n",
    "section": "",
    "text": "Читання даних з консолі R можна здійснювати за допомогою функцій scan() та readline().\nreadline() - читає рядок з консолі та записує його в змінну. Розглянемо приклад:\n\ntext <- readline(prompt = \"Text to ask user input: \") # prompt a text to view\n\nФункція scan() зчитує дані з консолі та зберігає їх у векторі. Приклад використання у RStudio Desktop:\n data <- scan() 1: 12 5 3: 2 4:\n> z [1] 12 5 2"
  },
  {
    "objectID": "06-r-input-output.html#виведення-даних",
    "href": "06-r-input-output.html#виведення-даних",
    "title": "\n6  Введення-виведення даних\n",
    "section": "\n6.2 Виведення даних",
    "text": "6.2 Виведення даних\nДля виведення даних у RStudio можна просто скористатися назвою змінної або використати функцію print().\n\nx <- 5\ny <- 10\nprint(x + y)\n\n[1] 15\n\n\nЩе однією корисною функцією є cat(). Вона використовується для виведення об’єктів, конкантенації тексту та значень змінних. Приклад:\n\ncat(\"Some text\", 1, \"more text\")\n\nSome text 1 more text\n\n\nУ цьому посібнику часто використовуються також функції paste() та paste0() для конкантенації тексту та значень змінних перед виведенням. Синтаксис функції paste() настпуний paste(..., sep = \" \", collapse = NULL). Параметр sep визначає роздільник між елементами, а collapse - роздільник між рядками. Приклад:\n\npaste(\"file\", \"number\", \"32\") # default separator is space \" \"\n\n[1] \"file number 32\"\n\n\n\npaste(\"file\", \"number\", \"32\", sep = \"_\") # separator underline \"_\"\n\n[1] \"file_number_32\"\n\n\nУсі параметри перед сепаратором (sep) повинні бути розділені комами.\nФункція paste0(…, collapse = NULL) працює так само, але не використовує сепаратор між елементами. Приклад:\n\nprint(paste0(\"file\", \"number\", \"32\"))\n\n[1] \"filenumber32\""
  },
  {
    "objectID": "07-r-variables.html",
    "href": "07-r-variables.html",
    "title": "\n7  Оголошення та ініціалізація змінних\n",
    "section": "",
    "text": "Базовим поняттям практично усіх мов програмування є змінна. Змінна дозволяє записати значення або об’єкт та назвати його для подальшого доступу, зміни, видалення по імені.\nНаприклад, присвоєння змінній my_variable значення 10 записується так: my_variable <- 5 або my_variable = 5.\nОперація надання змінній певного значення у програмуванні називається присвоєнням.\n\n\n\n\n\n\nImportant\n\n\n\nВажливо! Зверніть увагу, що присвоєння (<-, =) та рівність (==) це різні поняття. Оператор == здіснює перевірку співпадіння значення двох змінних/об’єктів та повертає результат у вигляді логічного значення TRUE (якщо значення рівні) або FALSE (якщо значення не рівні).\n\n\nЗнак <- не є часто використовуваним у різних мовах програмування, зазвичай для присвоєння користуються =. Проте в R освновним способом засобом початкової ініціалізації змінних є <-.\nТакож у програмуванні на R використовуються оператори присвоєння <<-, ->, ->>. Про них можна прочитати за лыками нижче.\n\n\n\n\n\n\nTip\n\n\n\nРекомендую почитати про різницю між операторами присвоєння у R <- та = тут:\n\n\nWhy do we use arrow as an assignment operator? (Colin FAY).\n\nDifference between assignment operators in R (Ren Kun).\n\nAssignment Operators.\n\n\n\nПриклад:\n\nx <- 45\ny <- 10\nz <- x + y # z = 45 + 10\nz\n\n[1] 55\n\n\nРозберемо приклад, описаний вище:\n\nУ першому рядку оголошується змінна x і їй присвоюється значення 45.\nУ другому рядку оголошується змінна y і їй присвоюється значення 10.\nУ третьому рядку оголошується змінна z і їй присвоюється значення суми x + y. # у R використовується як коментар коду, текст написаний після нього ігнорується.\n\nУ четвертому рядку відбувається виведення на консоль змінної z."
  },
  {
    "objectID": "07-r-variables.html#правила-іменування-змінних",
    "href": "07-r-variables.html#правила-іменування-змінних",
    "title": "\n7  Оголошення та ініціалізація змінних\n",
    "section": "\n7.2 Правила іменування змінних",
    "text": "7.2 Правила іменування змінних\nЄ кілька основних правил іменування змінних у R: 1. Ім’я змінної може складатися з букв [a-z, A-z], цифр [0-9], крапки . та нижнього підкреслювання _. 2. Ім’я змінної повинно починатися з букви або крапки. Якщо воно починається з крапки, то наступним символом повинна бути буква. 3. Не можна використовувати зарезервовані ключові слова мови програмування для іменування змінних, наприклад, TRUE/FALSE.\nІм’я змінної не може містити пробіл (space). Якщо є потреба назвати об’єкт кількома словами, то їх зазвичай розділяють підкресленням _ або крапкою .. Наприклад, змінну можна назвати my_variable_name або my.variable.name. Назва myVariableName (camel case) теж буде коректно сприйнята мовою програмування R, проте такий запис тут вживається не часто.\nПриклад коректного іменування змінних: total, zminna, Sum, .length_of_something, Number123, x_1.\nПриклад неправильного іменування змінних: tot@l, 5x_1, _variable, FALSE, .0ne."
  },
  {
    "objectID": "08-r-basic-types.html",
    "href": "08-r-basic-types.html",
    "title": "\n8  Базові типи даних R\n",
    "section": "",
    "text": "Усі мови програмування мають власну типізацію даних з якими працюють. Тип даних - це набір властивостей певних об’єктів та операцій, що можна з ними виконувати. Так, наприклад, з цілими числами можна виконувати арифметичні операції додавання, віднімання та інші. Набори символів (простими словами текст) зазвичай можуть використовуватися для пошуку у них елементів, редагування (шляхом видалення частини існуючого або додавання нового тексту), склеювання та розділення на частини.\nУ R, на відміну від строго типізованих мов програмування, тип даних визначається на основі поточного значення елемента і може змінюватися у процесі виконання.\nРозгялнемо приклад коду з мови програмування C# (мова родом із C/Java):\nint a = 10;\na = \"some text\";\nПодібний код у C# передбачає створення нової змінної a типу int (integer - ціле число), а потім відбувається присвоєння для a текстового фрагмента (тип string у С#). Такий код не буде запущено і виникне помилка компіляції.\nРозглянемо приклад коду з R:\n\na <- 10\na <- \"some text\"\na\n\n[1] \"some text\"\n\n\nТакий код виконається і на консоль буде виведено some text, адже у 1 першому рядку було присвоєно ціле число, у другому - текст. Таким чином R має динамічну типізацію, що дозволяє у ту ж саму змінну записати значення різних типів. Проте варто пам’ятати, що попереднє значення буде втрачено.\nДо базових типів даних у R варто віднести:\n\nЧисла з дробовою частиною (decimal numbers), як наприклад, 4.0, 15.214, що називаються numeric(s).\nНатуральні числа (natural numbers), як наприклад, 4, 15, що називаються integer(s).\nЛогічні значення (boolean values), тобто TRUE та FALSE (які також можна скорочено записувати T та F), що називаються logical.\nТекст або рядки (string values), як наприклад, \"Hello\", \"12 is number\", що називаються character(s).\n\nОголосимо для прикладу три змінні: my_numeric - число, my_character - текст, my_logical - логічне значення.\nmy_numeric <- 5\nmy_character <- \"universe\"\nmy_logical <- FALSE\nЗамінимо значення my_character <- \"5\" та спробуємо знайти суму значень:\n\nmy_character <- \"5\"\nmy_sum <- my_numeric + my_character\n\nУ результаті виклання даного коду ми отримаємо помилку, адже значення 5 та \"5\" є елементами різних типів даних, перевіримо типи за допомогю функції class():\n\nclass(5)\n\n[1] \"numeric\"\n\nclass(\"5\")\n\n[1] \"character\"\n\n\nВиконання коду class(5) показує нам, що 5є значенням числового типу даних numeric, а class(\"5\") відповідає тексту character, тому арифметична операція додавання між цими значеннями неможлива."
  },
  {
    "objectID": "08-r-basic-types.html#перевірка-та-привдення-типів-даних",
    "href": "08-r-basic-types.html#перевірка-та-привдення-типів-даних",
    "title": "\n8  Базові типи даних R\n",
    "section": "\n8.2 Перевірка та привдення типів даних",
    "text": "8.2 Перевірка та привдення типів даних\nУ випадку коли тип даних потрібно визначити у процесі виконання програми/коду та перетворити значення використовується приведння типів даних.\nПриведення типів даних - операція перетворення значення з одного типу даних в інший. Важливо памятати, що не завжди приведення типів даних може бути здійснено. Так, наприклад, значення \"5\" (character) можна досить просто привести до 5 (numeric), проте \"five\" не буде зрозумілим для інтерпритатора.\nДля перевірки належності елемента до певного типу даних використовують спеціальну функцію is.назва_типу(значення). Ця функція повертає TRUE, якщо елемент належить даному типу і FALSE, якщо не належить.\nРозглянемо приклад:\n\nmy_numeric <- 5\nmy_character <- \"five\"\nmy_logical <- FALSE\n\nis.numeric(my_numeric)\n\n[1] TRUE\n\nis.character(my_numeric)\n\n[1] FALSE\n\n\nДля перетворення типу даних можна скористатися функцією as.назва_типу(значення). У результаті виконання функції буде повернуто значення потрібного типу або пусте значення NA, якщо таке приведення не є можливим:\n\na <- 5\nb <- \"10\"\nc <- \"10, 20\"\nas.numeric(b)\n\n[1] 10\n\nas.numeric(c)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\nРезультат виконання функцій можна записувати у змінні і використовувати у наступних обчисленнях:\n\na <- 5\nb <- \"10\"\nb <- as.numeric(b)\na + b\n\n[1] 15\n\n\n\nnumber <- as.integer(54)\ntypeof(number)\n\n[1] \"integer\"\n\nclass(number)\n\n[1] \"integer\"\n\n\nПовний перелік типів та методів перевірки і приведення їх типів ображений нижче:\n\nБазові типи даних R, методи перевірки та приведення\n\nНазва типу\nМетод перевірки типу\nМетод приведення типу\n\n\n\nArray\nis.array()\nas.array()\n\n\nCharacter\nis.character()\nas.character()\n\n\nComplex\nis.complex()\nas.complex()\n\n\nDataframe\nis.data.frame()\nas.data.frame()\n\n\nDouble\nis.double()\nas.double()\n\n\nFactor\nis.factor()\nas.factor()\n\n\nList\nis.list()\nas.list()\n\n\nLogical\nis.logical()\nas.logical()\n\n\nMatrix\nis.matrix()\nas.matrix()\n\n\nNumeric\nis.numeric()\nas.numeric()\n\n\nRaw\nis.raw()\nas.raw()\n\n\nTime series (ts)\nis.ts()\nas.ts()\n\n\nVector\nis.vector()\nas.vector()"
  },
  {
    "objectID": "08-r-basic-types.html#приклади-розвязання-завдань",
    "href": "08-r-basic-types.html#приклади-розвязання-завдань",
    "title": "\n8  Базові типи даних R\n",
    "section": "\n8.3 Приклади розв’язання завдань",
    "text": "8.3 Приклади розв’язання завдань\nЗавдання 1. Сума введених чисел\nЗнайти суму введених з клавіатури чисел. Для введення інформації скористатися функцією readline(prompt = \"Text\").\nРозв’язання:\n\n# works on console and notebook / run this code line by line\na <- readline(prompt = \"Enter A:\") # read a\nb <- readline(prompt = \"Enter B:\") # read b\n\na <- as.numeric(a) # convert character to numeric\nb <- as.numeric(b) # convert character to numeric\n\nsum <- a + b\nsum\n\nРезультат виконання:\nEnter A: 10\nEnter B: 45\n55"
  },
  {
    "objectID": "09-r-operators.html",
    "href": "09-r-operators.html",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "",
    "text": "R можна використовувати як звичайни калькулятор.\nРозглянемо набір звичних арифметичних операторів, що відомі з початкової школи:\n\nДодавання: +.\nВіднімання: -.\nДілення: /.\nМноження: *.\n\nА також більш складні оператори:\n\nПіднесення до степеня: ^ (вводиться з клавіатури як Shift+6 на ENG-розкладці клавіатури).\nОстача від ділення (ще може називатися “ділення по модулю”): %% (вводиться з клавіатури як Shift+5).\nДілення націло: %/%.\n\nРозглянемо приклад додавання чисел:\n\n5 + 10\n\n[1] 15\n\n\n\n5 + 4 + 15\n\n[1] 24\n\n5 + 53 + 343\n\n[1] 401\n\n\n\n(5 + 8) + (4 + 9)\n\n[1] 26\n\n\n\n\n\n\n\n\nNote\n\n\n\nПримітка. Використання “круглих” дужок у прогрмуванні виразах має пріоритет аналогічний до загальноприйнятих у математиці.\n\n\nРозглянемо приклад віднімання чисел:\n\n47 - 21\n\n[1] 26\n\n\n\n15 - (10 - 25)\n\n[1] 30\n\n\n\n\n\n\n\n\nNote\n\n\n\nПримітка. Заміна знаків до/в “дужках” тут працює так само як працювала у школі :)\n\n\nПриклади множення чисел:\n\n5 * 3\n\n[1] 15\n\n\n\n5 * (2 + 5)\n\n[1] 35\n\n\nПриклади ділення чисел:\n\n12 / 2\n\n[1] 6\n\n\n\n(4 + 7) / 3\n\n[1] 3.666667\n\n\nПіднесення до степеня за допомогю оператора ^ є досить простим. Так, наприклад, 3^2 (у математиці записується як \\(3^2\\)) дорівнює 9, а 2^3 - це 2*2*2 і дорівнює 8.\n\n5^2\n\n[1] 25\n\n\n\n(1+3)^3 + 100 \n\n[1] 164\n\n\nОстача від ділення дозволяє знайти залишок одного числа від ділення на інше число.\nНаприклад, остача від ділення націло 5 на 2 дорівнює 1, бо 2 * 2 (=4) + 1 = 5\n\n28 %% 7\n\n[1] 0\n\n\n\n17 %% 5\n\n[1] 2\n\n\nПримітка. Пробіли між цифрами та операторами можна не лишати, це робиться для зручності візуального сприйняття коду.\nДілння націло залишає лише цілу частину від ідленнядвох чисел:\n\n28 %/% 7\n\n[1] 4"
  },
  {
    "objectID": "09-r-operators.html#оператори-відношення",
    "href": "09-r-operators.html#оператори-відношення",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "\n9.2 Оператори відношення",
    "text": "9.2 Оператори відношення\nОператори відношення відповідають за порівнняння двох об’єктів між собою та повертають значення логічного типу TRUE, якщо результат істинний та FALSE, якщо результат хибний.\nПерелік операторів відношення:\n\nБільше або дорівнює >=.\nМенше <.\nМенше або дорівнює <=.\nДорівнює ==.\nНе дорівнює !=\n\n\nДля демонстрації принципів роботи операторів відношення оголосимо 3 змінні a, b та c.\n\na <- 12\nb <- 5\nc <- 7\n\nРозгялнемо кілька прикладів використання описаних вище операторів.\nОператори, що відповідають за первірку на “більше/менше”:\n\na > b\n\n[1] TRUE\n\nb + c < a\n\n[1] FALSE\n\nb + c <= a\n\n[1] TRUE\n\n\nОператори, що відповідають за перевірку на “рівність/нерівність”:\n\na != b\n\n[1] TRUE\n\na == b + c\n\n[1] TRUE\n\nb == c\n\n[1] FALSE"
  },
  {
    "objectID": "09-r-operators.html#chapter233",
    "href": "09-r-operators.html#chapter233",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "\n9.3 Логічні оператори",
    "text": "9.3 Логічні оператори\nДо логічних операторів у R відносяться:\n\n\n& - І (амперсант, Shift-7) - виконання усіх умов одночасно.\n\n| - АБО (вертикальна риска, Shift+\\) - виконання однієї із умов.\n\n! - НЕ (знак оклику, Shift+1) - заперечення.\n\n\n\n\n\n\n\nImportant\n\n\n\nЗверніть увагу, що у R існують також і оператори && та ||. Це також логічні оператори І та АБО. Проте їх відмінність полягає у тому, що “розширені” оператори порівнюють лише перші елементи векторів, у той час як “скорочені” усі елементи:\n\nx <- c(5, 8, 10)\ny <- c(3, 2, 5)\n\nprint(x)\n\n[1]  5  8 10\n\nprint(y)\n\n[1] 3 2 5\n\nx > 5 & y < 7\n\n[1] FALSE  TRUE  TRUE\n\n\n\nx > 5 && y < 7\n\n[1] FALSE\n\n\n\n\nВажливо розуміти відмінності між цими операторами вміти використовувати результи їх роботи. Для початку варто розглянути таблицю істинності:\n\nТаблиця істинності логічних операторів\n\nA\nB\nОператор І\n\nОператор АБО\n\nЗаперечення A (не A)\n\n\n\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nFALSE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nTRUE\nTRUE\nTRUE\nTRUE\nFALSE\n\n\n\nПриклади використання логічних операторів зображені нижче.\nОператор І (and):\n\n\n\n\na <- 12\nb <- 7\n\na > 10 & b < 10\n\n[1] TRUE\n\na > 10 & b > 10\n\n[1] FALSE\n\na < 10 & b < 10\n\n[1] FALSE\n\na < 10 & b > 10\n\n[1] FALSE\n\n\nОператор АБО (or):\n\na > 10 & b < 10\n\n[1] TRUE\n\na > 10 | b > 10\n\n[1] TRUE\n\na < 10 | b < 10\n\n[1] TRUE"
  },
  {
    "objectID": "09-r-operators.html#приклади-виконання-завдань",
    "href": "09-r-operators.html#приклади-виконання-завдань",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "Приклади виконання завдань",
    "text": "Приклади виконання завдань\nЗавдання 1. Ділення по модулю\nЯким буде результат виконання наступних команд?\n\na <- 10\nb <- 4\n\na %% b > 0 # what is result \n\n[1] TRUE\n\n\nРезультат:\nTRUE\nПояснення: \\(a\\) %% \\(b = 2\\), бо остача від ділення \\(10\\) на \\(4\\) рівна \\(2\\), а \\(2 > 0 = true\\).\nЗавдання 2. Ділення по модулю\nЯким буде результат виконання наступних команд?\nПідзавдання 1:\n\na <- 7\nb <- 12\nc <- a - b %% 2\n\nc\n\nРезультат:\n7\nПідзавдання 2:\n\nc > 0 & b > a\n\nРезультат:\nTRUE\nПідзавдання 3:\n\nc < 0 | b > a\n\nРезультат:\nTRUE"
  },
  {
    "objectID": "10-r-conditions-if-else.html",
    "href": "10-r-conditions-if-else.html",
    "title": "\n10  Розгалуження\n",
    "section": "",
    "text": "Якщо є потреба перевірити у коді програми виконання якоїсь умови та за її результатами перейти до одного із блоків виконання зазвичай використовують оператор if-else. Загальний вигляд формату використання оператора if-else:\n if (умова) {\n    #інструкція\n  }\n  else {\n    #інструкція\n  }\nВираз умова повинен повертати результат у вигляді елемента логічного типу. Тобто, умова може бути або true, або false.\nЯкщо умова рівна true, то виконається інструкція (або код) записана у дужках після if. Якщо ж умова рівна false, то виконається інструкція записана у дужках після else.\n\n\n\n\n\n\nNote\n\n\n\nСимвол # перед кодом означає коментар, тобто код, який не бачитиме інтепретатор мови програмування.\n\n\nЯкщо після if або else тільки одна інструкція (можна ототожнити з один рядком коду), то «фігурні» дужки {} не є обов’язковими.\nКонструкції if-else можуть вкладеними одна в одну без обмежень по глибині. Проте дуже глибокої вкладеності варто уникати, адже це ускладнює читання та розуміння коду програми.\nif (умова1)\n{\n  if (умова2)\n  {\n    #інструкція\n  }\n}\n\n\n\n\n\n\nNote\n\n\n\nif є обов’язковим і повинно існувати у всіх подібних конструкціях, у той же час else – необов’язковий.\n\n\nТакож конструкція if-else може мати структуру дерева із багатьма розгалуженнями. Така структура зазвичай записується як if-else-if:\nif (умова1)\n  { #код }\n  else if (умова2)\n      { #код }\n      else if (умова3)\n          { #код }\n          else { #код }\nВирази обчислюються зверху-вниз. Якщо один із виразів (умова) отримає істинний результат (true), то програмний код, пов’язаний із цією гілкою розгалуження виконається, а всі інші гілки будуть пропущені. Якщо ж не виконається жодна з умов, то буде запущено код всередині останньої інструкції else (у цьому випадку else теж не обов’язковий).\nРозгялнемо приклади використання конструкції if-else. Код нижче дозволяє перевірити, яке з двох цілих чисел є більшим:\n\na <- 10\nb <- 5\n\nif(a > b) {\n    print(\"A > B\")\n} else if (b > a){\n    print(\"B > A\")\n} else {\n    print(\"A equals B\")\n}\n\n[1] \"A > B\""
  },
  {
    "objectID": "10-r-conditions-if-else.html#тернарний-оператор",
    "href": "10-r-conditions-if-else.html#тернарний-оператор",
    "title": "\n10  Розгалуження\n",
    "section": "\n10.2 Тернарний оператор",
    "text": "10.2 Тернарний оператор\nТернарний оператор – це спосіб запису умовного виразу в один рядок. Він використовується, коли потрібно присвоїти значення змінній в залежності від умови. Синтаксис тернарного оператора у R відрізняється від інших мов програмування (класично це умова ? вираз_якщо_true : вираз_якщо_false).\nОператор розгалуження if-else у R може повертати та записувати значення у змінну:\n\nvalue <- 10\nx <- if(value %% 2 == 0) \"even\" else \"odd\"\nx\n\n[1] \"even\"\n\n\nПроте сильною стороною R є саме робота з векторами. Тому, якщо потрібно виконати умовну перевірку для кожного елемента вектора, то краще використати функцію ifelse(). Синтаксис виклику:\nifelse(condition, a, b)\nде condition – вектор умов, a – вектор значень, які будуть повернуті, якщо умова condition істинна, b – вектор значень, які будуть повернуті, якщо умова condition не істинна.\nРозглянемо приклад. Потрібно створити вектор, який містить значення 1 для значень >= 0 та 0 для значень < 0 на основі наявного вектора x:\n\n x <- c(-6, 2, -3, 4, 5)\n binary_vector <- ifelse(x > 0, 1, 0)\n print(binary_vector)\n\n[1] 0 1 0 1 1\n\n\nТакож оператор ifelse можна використовувати і для заміни значень вектора. Наприклад, потрібно замінити всі значення Yes/No на 1/0:\n\nx <- c(\"Yes\", \"No\", \"Yes\", \"Yes\", \"No\")\nprint(x)\n\n[1] \"Yes\" \"No\"  \"Yes\" \"Yes\" \"No\" \n\nx <- ifelse(x == \"Yes\", 1, 0)\nprint(x)\n\n[1] 1 0 1 1 0"
  },
  {
    "objectID": "10-r-conditions-if-else.html#приклади-розвязання-завдань",
    "href": "10-r-conditions-if-else.html#приклади-розвязання-завдань",
    "title": "\n10  Розгалуження\n",
    "section": "Приклади розв’язання завдань",
    "text": "Приклади розв’язання завдань\nЗавдання 1. Парні/непарні числа\nНапишіть програму, що виводить консоль інформацію про те число парне чи ні. Значення \\(0\\) потрібно потрібно також перевірити і вивести у разі його введення \"ZERO\".\nРозв’язання\n\na <- readline(prompt = \"Enter A:\") # read a\na <- as.numeric(a) \nremainder <- a %% 2\nif(a == 0) {\n  print(\"ZERO\")  \n} else if(remainder == 0) {\n  print(\"EVEN\")\n} else if (remainder == 1) {\n  print(\"ODD\")\n}\n\nРезультат виконання коду:\nEnter A: 2\n[1] \"EVEN\""
  },
  {
    "objectID": "11-r-loops.html",
    "href": "11-r-loops.html",
    "title": "\n11  Цикли у R\n",
    "section": "",
    "text": "Цикли у програмуванні використовуються для виконання повторюваних операцій. В R є три типи циклів: for(“R for Loop,” n.d.), while(“R for Loop,” n.d.) та repeat(sabir, n.d.)."
  },
  {
    "objectID": "11-r-loops.html#цикл-for",
    "href": "11-r-loops.html#цикл-for",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.1 Цикл for\n",
    "text": "11.1 Цикл for\n\nЦикл for у R використовується для повторюваних операцій над елементами вектора. Ми раніше уже використовували вектори для фнших прикладів:\n\nx <- c(2, 4, 5, 7, 9, 11, 14)\nx\n\n[1]  2  4  5  7  9 11 14\n\n\nСинтаксис циклу for виглядає наступним чином:\nfor (value in sequence) { \n  code\n}\nДе value - це змінна, яка буде використовуватись для доступу до елементів вектора sequence. code - це код, який буде виконуватись для кожного елемента вектора sequence.\nДля прикладу, давайте знайдемо кількість непарних елементів вектора x:\n\n# створюємо змінну count та присвоюємо їй значення 0\neven_count <- 0                   \n# створюємо вектор x\nx <- c(2, 4, 5, 7, 9, 11, 14)     \n\nfor (i in x) {\n  # якщо елемент i не парний\n  if (i %% 2 != 0) {     \n    # збільшуємо значення even_count на 1         \n    even_count <- even_count + 1  \n    # виводимо значення i та even_count\n    print(paste(\"i: \", i, \" | even_count: \", even_count)) \n  }\n}\n\n[1] \"i:  5  | even_count:  1\"\n[1] \"i:  7  | even_count:  2\"\n[1] \"i:  9  | even_count:  3\"\n[1] \"i:  11  | even_count:  4\"\n\nprint(even_count)\n\n[1] 4\n\n\nУ прикладі вище, цикл for виконався 7 разів, бо саме стльіки значень у векторі x. На кожній ітерації циклу змінні i отримує нове значення з вектора x.\nТакож цикл for можна використовувати для роботи з індексами елементів вектора (або іншої колекції). Розвязати попередній приклад можна також так:\n\n# створюємо змінну count та присвоюємо їй значення 0\neven_count <- 0                   \n# створюємо вектор x\nx <- c(2, 4, 5, 7, 9, 11, 14)     \n\nfor (i in 1:length(x)) {\n  # якщо елемент **x[i]** не парний\n  if (x[i] %% 2 != 0) { \n    # збільшуємо значення even_count на 1             \n    even_count <- even_count + 1    \n    # виводимо значення i та even_count\n    print(paste(\"i: \", i, \" | even_count: \", even_count)) \n  }\n}\n\n[1] \"i:  3  | even_count:  1\"\n[1] \"i:  4  | even_count:  2\"\n[1] \"i:  5  | even_count:  3\"\n[1] \"i:  6  | even_count:  4\"\n\nprint(even_count)\n\n[1] 4\n\n\n\n\n\n\n\n\nTip\n\n\n\nФункція length() повертає довжину вектора/послідовності."
  },
  {
    "objectID": "11-r-loops.html#цикл-while",
    "href": "11-r-loops.html#цикл-while",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.2 Цикл while\n",
    "text": "11.2 Цикл while\n\nЦикл while виконується поки вказана умова є істинною, а синтаксис виглядає наступним чином:\nwhile (condition) {\n  code\n}\nде condition - це умова, яка повинна бути істинною, а code - це код, який буде виконуватись поки умова condition є істинною.\nНаприклад, виведемо на консоль усі парні числа від 1 до 10:\n\ni <- 1\n\nwhile(i <= 10) {\n  # збільшуємо значення i на 1 на кожній ітерації циклу\n  i <- i + 1 \n  # перевіряємо i на парність\n  if (i %% 2 == 0) {\n    print(i)\n  }\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n\n\nВикористовуючи цикл while Ви моежете виконувати"
  },
  {
    "objectID": "11-r-loops.html#команди-break-та-next",
    "href": "11-r-loops.html#команди-break-та-next",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.3 Команди break та next\n",
    "text": "11.3 Команди break та next\n\nКоманди break та next дозволяють виконувати певні дії в циклі.\nТак, break зупиняє виконання поточного циклу, а next переходить на виконання наступної ітерації циклу, на виконуючи код після неї.\nРозглянемо наступний приклад: потрібно вивести на консоль усі парні числа з поданого вектора x <- c(4, 6, 7, 1, -4, 0, 6, -8), але при цьому пропускати від’ємні числа, а при знаходженні 0 зупинити виконання циклу.\n\nx <- c(4, 6, 7, 1, -4, 0, 6, -8)\n\nfor(i in x) {\n  # якщо i < 0, то переходимо на наступну ітерацію циклу\n  if(i < 0) \n    next\n  # якщо i == 0, то зупиняємо виконання циклу та виводимо повідомлення\n  if(i == 0) {\n    print(\"ZERO!!!\")\n    break\n  }\n  # якщо i парне, то виводимо його на консоль\n  if(i %% 2 == 0) \n    print(i)\n}\n\n[1] 4\n[1] 6\n[1] \"ZERO!!!\""
  },
  {
    "objectID": "11-r-loops.html#цикл-repeat",
    "href": "11-r-loops.html#цикл-repeat",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.4 Цикл repeat\n",
    "text": "11.4 Цикл repeat\n\nЦикл repeat на відміну від for та while зупиняється лише коли виконано команду break та не має жодних умов виходу з нього. Синтаксис виглядає наступним чином:\nrepeat {\n  code\n  if(condition) {\n    break\n  }\n}\nПриклад використання циклу repeat:\n\ni <- 1\nrepeat {\n  print(i)\n  i <- i + 1\n  if(i > 10) {\n    break\n  }\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\nУ прикладі вище ми вивели на консоль усі числа від 1 до 10.\n\n\n\n\n“R for Loop.” n.d. W3Schools. https://www.w3schools.com/r/r_for_loop.asp.\n\n\nsabir. n.d. “R Repeat Loop.” R-Bloggers.com. https://www.r-bloggers.com/2022/07/r-repeat-loop/."
  },
  {
    "objectID": "12-userful-math.html",
    "href": "12-userful-math.html",
    "title": "\n12  Корисні математичні функції\n",
    "section": "",
    "text": "Функції у програмуванні мають ім'я/назву та () (круглі дужки). Виклик функції зазвичай має вигляд function_name(params)."
  },
  {
    "objectID": "12-userful-math.html#заокруглення-чисел",
    "href": "12-userful-math.html#заокруглення-чисел",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.1 Заокруглення чисел",
    "text": "12.1 Заокруглення чисел\nУ цьому розділі описано роботу функцій: round(), ceiling(), floor(), trunc(), signif().\nЯк ми знаємо з математики, що заокруглення чисел буває “вверх”, “вниз” або відносно деякого значення, зазвичай пов’язаного із цифрою 5 (3.6 заокруглюємо до цілого як \\(4\\), а \\(3.2\\) як \\(3\\), ввжаючи \\(3.5\\) межею.\n\n\n\n\n\n\nWarning\n\n\n\nУвага! Заокрулення чисел у програмуванні може призводити до помилок у результатах обчислень. Для задач бізнесу, фінансів або технічних процесів мінімальні відхилення можуть призводити до викривлених результатів або збоїв у системах.\n\n\n\n12.1.1 Функція round()\n\n\nПримітка. Тут і надалі функції будуть позначатися як назва() (назва і “круглі” дужки).\n\nДля заокруглення дійних чисел (з дробовою частиною) за правилом <0.5 & >=0.5 (не знаю як називається науково) використовується функція round(x, y), де x - число, y - точність (кількість знаків після коми/крапки). Наприклад:\n\nround(3.557, 2)\n\n[1] 3.56\n\nround(3.241, 2)\n\n[1] 3.24\n\nround(-3.557, 2)\n\n[1] -3.56\n\nround(-3.241, 2)\n\n[1] -3.24\n\n\nТакож можна використати round(x) з одним параметром, тоді заокруглення відбудеться до цілої частини, наприклад:\n\nround(124.345)\n\n[1] 124\n\n\n\n12.1.2 Функція floor()\n\nДля заокруглення до найближчого меншого цілого числа слід скористатися функцією floor():\n\nfloor(3.557)\n\n[1] 3\n\nfloor(3.241)\n\n[1] 3\n\nfloor(-3.557)\n\n[1] -4\n\nfloor(-3.241)\n\n[1] -4\n\n\n\n12.1.3 Функція ceiling()\n\nДля заокруглення до найближчого більшого цілого числа слід скористатися функцією ceiling():\n\nceiling(3.557)\n\n[1] 4\n\nceiling(3.241)\n\n[1] 4\n\nceiling(-3.557)\n\n[1] -3\n\nceiling(-3.241)\n\n[1] -3\n\n\n\n12.1.4 Функція trunc()\n\nФункція trunc() у R використовується для отримання найбільшого цілого числа, яке більше або рівне x. Простими словами це означає, що для чисел менших 0 (x < 0) trunc() працює як celing(), а для чисел більших нуля x > 0, як floor():\n\nx <- 5.34\nprint(paste(\"trunc:\", trunc(x), \"celing:\", ceiling(x), \"floor:\", floor(x), sep = \" \"))\n\n[1] \"trunc: 5 celing: 6 floor: 5\"\n\nx <- x * -1\nprint(paste(\"trunc:\", trunc(x), \"celing:\", ceiling(x), \"floor:\", floor(x), sep = \" \"))\n\n[1] \"trunc: -5 celing: -5 floor: -6\"\n\n\n\n12.1.5 Функція signif()\n\nІнколи виникає потреба заокруглити не десяткову частину числа, а десятки, сотні, тисячі і так далі. Розглядемо варіант, коли у нас є велике число \\(11 547 741.3\\) і нам потрібно коротко його записати як \\(11.5 млн\\). Для таких задач можна використати функцію signif(x,y), де x - число, яке потрібно заокруглити до певного порядку, y - порядок заокруглення (рахувати від початку). Наприклад:\n\nbig_number <- 11547741.3\nrounded_big_number <- signif(big_number,3)\nrounded_big_number\n\n[1] 11500000\n\nrounded_big_number / 1000000\n\n[1] 11.5"
  },
  {
    "objectID": "12-userful-math.html#послідовності-чисел",
    "href": "12-userful-math.html#послідовності-чисел",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.2 Послідовності чисел",
    "text": "12.2 Послідовності чисел\nПослідовності у програмуванні на R це вектори, які містять набір чисел. Найпростіший спосіб створити послідовність у R це використання оператора “двокрапка” :, наприклад:\n\nseq <- 1:4\nseq\n\n[1] 1 2 3 4\n\nclass(seq)\n\n[1] \"integer\"\n\n\n\n12.2.1 Функція seq()\n\nФункція seq() використовується для створення послідовностей чисел. Ця функція приймає наступні аргументи:\n\n\nfrom - початок послідовності\n\nto - кінець послідовності\n\nby - крок послідовності\n\nlength.out - довжина послідовності\n\nРозглянемо кілька прикладів використання функції seq().\nВиведемо числа від \\(1\\) до \\(10\\):\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nВиведемо числа від \\(0\\) до \\(10\\) з кроком \\(2.5\\):\n\nseq(0, 10, by = 2.5)\n\n[1]  0.0  2.5  5.0  7.5 10.0\n\n\nВиведемо та покажемо на графіку 50 чисел від \\(0\\) до \\(10\\) (крок у такому випадку обчислюється функцією самостійно):\n\ns <- seq(0, 10, length=50)\nprint(s)\n\n [1]  0.0000000  0.2040816  0.4081633  0.6122449  0.8163265  1.0204082\n [7]  1.2244898  1.4285714  1.6326531  1.8367347  2.0408163  2.2448980\n[13]  2.4489796  2.6530612  2.8571429  3.0612245  3.2653061  3.4693878\n[19]  3.6734694  3.8775510  4.0816327  4.2857143  4.4897959  4.6938776\n[25]  4.8979592  5.1020408  5.3061224  5.5102041  5.7142857  5.9183673\n[31]  6.1224490  6.3265306  6.5306122  6.7346939  6.9387755  7.1428571\n[37]  7.3469388  7.5510204  7.7551020  7.9591837  8.1632653  8.3673469\n[43]  8.5714286  8.7755102  8.9795918  9.1836735  9.3877551  9.5918367\n[49]  9.7959184 10.0000000\n\nplot(seq(0, 10), seq(0, 50, length=11), type=\"l\", col=\"blue\")\n\n\n\nРис. 12.1. Приклад візуалізації послідовності у R\n\n\n\n\n\n12.2.2 Функція rep()\n\nФункція rep() також використовується для створення послідовностей чисел, що повторюються. Ця функція приймає наступні аргументи:\n\n\nx - послідовність, що повторюється\n\ntimes - кількість повторень\n\neach - кількість повторень кожного елемента\n\nСинтаксис виклику:\nrep(x = <вектор>, \n    times = <кількість повторень ветора>, \n    each = <кількість повторень кожного елемента>)\nПриклади використання та результаи виконна коду подано нижче.\n\n# 123 повторюється 2 рази\nrep(1:3, times = 2)   \n\n[1] 1 2 3 1 2 3\n\n\n\n# вектор x повторюється 2 рази\nx <- c(5, 2, 7)\nrep(x, times = 2)   \n\n[1] 5 2 7 5 2 7\n\n\n\n# 1 повторюється 2 рази\n# 2 повторюється 1 раз\n# 3 повторюється 4 рази\nrep(1:3, times=c(2,1,4))  \n\n[1] 1 1 2 3 3 3 3\n\n\n\n# кожен елемент повторюється 2 рази\nrep(1:3, each=2) \n\n[1] 1 1 2 2 3 3\n\n\n\nx <- c(1,3,5)\nrep(x, each = 3, times = 2)\n\n [1] 1 1 1 3 3 3 5 5 5 1 1 1 3 3 3 5 5 5"
  },
  {
    "objectID": "12-userful-math.html#генерація-псевдовипадкових-чисел",
    "href": "12-userful-math.html#генерація-псевдовипадкових-чисел",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.3 Генерація псевдовипадкових чисел",
    "text": "12.3 Генерація псевдовипадкових чисел\nR має вбудовані функції для генерації псевдовипадкових чисел: runif(), sample().\n\n12.3.1 Функція runif()\n\nrunif() генерує послідовність випадкових чисел з рівномірним розподілом на відрізку \\([min, max]\\). Ця функція приймає наступні аргументи:\n\n\nn - кількість чисел;\n\nmin - мінімальне значення (за замовчуванням \\(0\\));\n\nmax - максимальне значення (за замовчуванням \\(1\\)).\n\nНаприклад, згенеруємо \\(5\\) випадкових значень на відрізку \\([min, max]\\):\n\nrunif(5)\n\n[1] 0.2957213 0.7791792 0.3870218 0.6465080 0.2381501\n\n\nВиведемо графік з \\(1000\\) випадкових знань на відрізку \\([0, 1]\\):\n\nx <- runif(1000)\nplot(x)\n\n\n\nРис. 12.2. Приклад візуалізації 1000 випадкових знань на відрізку [0, 1] з використанням функції runif()\n\n\n\n\n\n12.3.2 Функція sample()\n\nФункція sample() дозволяє вибрати числа випадковим чином із деякого набору (вектора).\nСинтаксис виклику:\nsample(x = <вектор>, \n       size = <кількість випадкових значень>, \n       replace = <TRUE/FALSE, >, \n       prob = <вектор з ймовірностями>)\nПрипустимо у нас є деякий вектор x:\n\nx <- 10:20\nprint(x)\n\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\nДля того аби виьрати одне із значень вектора x випадковим чином, використаємо функцію sample():\n\nsample(x)\n\n [1] 13 20 15 16 14 10 11 18 12 19 17\n\n\nЯкщо ми хочемо вибрати декілька значень вектора x випадковим чином, то використаємо аргумент size:\n\nsample(x, size = 4)\n\n[1] 12 16 15 17\n\nsample(x, size = 4)\n\n[1] 20 19 16 18\n\n\nЗверніть увагу, що у такому випадку усі значення завжди будуть різними у межах одного вибору.\nУ випадку, якщо потрібно вибрати значення з повтореннями, то використаємо аргумент replace:\n\nsample(x, size = 15, replace = TRUE)\n\n [1] 15 12 12 17 10 18 16 17 18 18 13 12 12 18 20\n\n\nЯкщо потрібно вибрати значення з деякими ймовірностями, то використаємо аргумент prob:\n\nt <- sample(c(1,2), size = 1000, replace = T, prob = c(80, 20))\nhist(t, breaks = 2, col = c('blue', 'green'))\n\n\n\nРис. 12.3. Приклад візуалізації гістограми у R"
  },
  {
    "objectID": "12-userful-math.html#інші-математичні-функції-та-константи-r",
    "href": "12-userful-math.html#інші-математичні-функції-та-константи-r",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.4 Інші математичні функції та константи R",
    "text": "12.4 Інші математичні функції та константи R\nОкрім описаного вище набору функцій R містить дуже велику кількість реалізованих функцій з різних сфер науки, бізнесу, техніки тощо. Прочитати про них можна з офіційної документації пакетів, у яких вони реалізовані та знайти за допомогою функції help() або ?name.\nДалі розглянемо перелік найпоширеніших функцій, що використовуються для розв’язання навчальних задач під час вивчення основ програмування.\n\nПопулярні математичні функції в R\n\n\nФункція\nПризначення, опис\n\n\n\nlog(x)\nЛогарифм числа x за основою e\n\n\n\nlog(x,n)\nЛогарифм числа x за основою n\n\n\n\nexp(x)\n\ne у степені x\n\n\n\nsqrt(x)\nКорінь квадратний числа x\n\n\n\nfactorial(x)\nФакторіал числа x\n\n\n\nabs(x)\nМодуль числа x\n\n\n\n\nТакож у R доступні ряд тригонометричних функцій, які вивчалися у школі і не тільки, серед них cos(x), sin(x), tan(x), а також acos(x), asin(x), atan(x), acosh(x), asinh(x), atanh(x).\nДетальніше про кожну з них можна почитати у документації за допомогою кодманди help(function)."
  },
  {
    "objectID": "12-userful-math.html#приклади-розвязання-завдань",
    "href": "12-userful-math.html#приклади-розвязання-завдань",
    "title": "\n12  Корисні математичні функції\n",
    "section": "Приклади розв’язання завдань",
    "text": "Приклади розв’язання завдань\nЗавдання 1. Генерація випадкових чисел\nЗгенеруйте \\(1000\\) випадкових чисел у діапазоні \\([0,1]\\). Заокругліть їх до десятих (“2 знаки після коми/крапки”). Побудуйте графік за допомогою функції plot().\nРозв’язання\n\nx <- runif(1000)\nx <- round(x, 1)\nplot(x)\n\n\n\nРис. 12.4. Графік до Завдання 1. Генерація випадкових чисел"
  },
  {
    "objectID": "13-r-functions.html",
    "href": "13-r-functions.html",
    "title": "\n13  Створення функцій\n",
    "section": "",
    "text": "Усі мови програмування окрім набору вбудованих функцій також дозволяють створювати власні функції, що інколи жє наобхідним для вирішення задачі, а інколи спрощує написаний код та полегшує його тестування.\nУсі функції мають кілька спільних характеристик:\n\nФункція - це блок коду, що виконується при її виклику по імені.\nФункція може приймати аргументи, які використовуються в коді функції.\nФункція може повертати значення, яке може бути використано в коді, де функція була викликана.\n\nСтворення фукнцій у R відбувається з використанням ключового слова function, а синтаксис має вигляд:\n\nmy_func <- function() {\n  print(\"this is my first function\")\n}\n\nmy_func()\n\n[1] \"this is my first function\"\n\n\nУ рядках 1-3 створюється функція my_func, яка не приймає аргументів, але виконує дію виводу тексту \"this is my first function\" на екран. У рядку 5 функція викликається.\nУвага. Виконання функції відбувається у момент виклику, а не у момент створення.\nУ прикладі вище my_func є імям функції, а my_func() - її виликом."
  },
  {
    "objectID": "13-r-functions.html#передача-аргументів-та-повернення-значень",
    "href": "13-r-functions.html#передача-аргументів-та-повернення-значень",
    "title": "\n13  Створення функцій\n",
    "section": "\n13.2 Передача аргументів та повернення значень",
    "text": "13.2 Передача аргументів та повернення значень\nФункції також можуть приймати аргументи. Ви можете додати стільки аргументів, скільки вам потрібно, розділяючи їх комами.\nНаприклад, створимо функцію для конвретації валюти з гривні у долари:\n\nuah_to_usd <- function(uah) {\n  usd_rate <- 40\n  usd_amount <- uah / usd_rate\n  print(usd_amount)\n}\n\nuah_to_usd(200)\n\n[1] 5\n\n\nУ прикладі вище ми вивели значення прямо з функції, проте частіше виникає потреба повернути значення з функції, щоб використати його далі. Для цього використовується ключове слово return. Перепишемо нашу функцію:\n\nuah_to_usd <- function(uah) {\n  usd_rate <- 40\n  usd_amount <- uah / usd_rate\n  return(usd_amount)\n}\n\ntotal_usd <- uah_to_usd(200)\nprint(paste(\"Total USD:\", total_usd))\n\n[1] \"Total USD: 5\"\n\n\nНасправді у R можна не використовувати return, а просто використовувати останнє значення, яке буде обчислено в функції. Однак, це не є хорошою практикою, оскільки це може призвести до помилок, які важко знайти у коді програми:\nuah_to_usd <- function(uah) {\n  usd_rate <- 40\n  usd_amount <- uah / usd_rate\n  return(usd_amount)\n}"
  },
  {
    "objectID": "13-r-functions.html#аргументи-функції-за-замовчуванням",
    "href": "13-r-functions.html#аргументи-функції-за-замовчуванням",
    "title": "\n13  Створення функцій\n",
    "section": "\n13.3 Аргументи функції за замовчуванням",
    "text": "13.3 Аргументи функції за замовчуванням\nРозширимо нашу попереню функцію та будемо також передавати курс USD/UAH як параметр. Якщо курс не передано, то використовуємо курс за замовчуванням:\n\nuah_to_usd <- function(uah, usd_rate = 40) {\n  usd_amount <- uah / usd_rate\n  return(usd_amount)\n}\n\n# Буде використано курс за замовчуванням\nuah_to_usd(200)\n\n[1] 5\n\n# Буде використано курс 42.5\nuah_to_usd(200, 42.5)\n\n[1] 4.705882"
  },
  {
    "objectID": "13-r-functions.html#приклади-розвязання-завдань",
    "href": "13-r-functions.html#приклади-розвязання-завдань",
    "title": "\n13  Створення функцій\n",
    "section": "Приклади розв’язання завдань",
    "text": "Приклади розв’язання завдань\nЗавдання 1. Середнє значення\nНапишіть функцію, що обчислює середнє значення чисел у векторі та повертає його. Точність обчислень - \\(2\\) знаки після коми.\nПримітка. Під час розвязання задачі не можна користуватися жодними готовими вбудованими функціямию\nРозв’язання\n\naverage <- function(x) {\n  count <- 0\n  sum <- 0\n  for(i in x) {\n    count <- count + 1\n    sum <- sum + i\n  }\n  return(round(sum/count, 2))\n}\n\nvector <- c(5, 2, 7, 9, 2, 1)\n\naverage(vector)\n\n[1] 4.33\n\n\nЗавдання 2. Створення вектору із випадковими числами\nНаписати функцію, що генерує вектор випадкових чисел у вказаному діапазоні. Якщо діапазон користувачем не вказано, то генеруються значення у діапазоні від \\(0\\) до \\(100\\). Також варто врахувати, що випадкові числа можуть мати дробову частину. У такому випадку потрібно передати\nРозв’язання\n\nrandomNumbers <- function(n, min = 0, max = 100, intOnly = TRUE) {\n  if(intOnly) {\n    return(sample(min:max, n, replace = TRUE))\n  } else {\n    return(runif(n, min, max))\n  }\n}\n\nrandomNumbers(10, intOnly = F)\n\n [1] 58.26607 86.21543 68.58907 64.44715 60.22328 27.22499 33.36881 28.76801\n [9] 24.68268 99.14092\n\nrandomNumbers(10, 100, 200)\n\n [1] 113 101 145 107 124 102 107 175 104 136\n\n\nЗавдання 3. Депозитний калькулятор\nНапишіть функцію, що обчислює суму депозиту на кінець терміну вкладу. Функція повинна приймати наступні аргументи:\n\n\nP - сума депозиту у гривні.\n\nn - термін депозиту у місяцях.\n\nr - щомісячна відсоткова ставка за депозитом\nmonthly capitaliztion\n\nDuring caluculations print every month info in style: “Month: 1 / Total: 1010 / 10 EUR” Suppose I deposit 1000 (P) dollars in bank every month for 60 (n) months and bank pays me 1 (rate) percent per month as interest. Hence I can calculate the interest on each deposit as:\n\\(A = P*(1+\\frac{r}{n})^n\\)\nThe formula used is A = P(1+r/n) ^ n, where ‘A’ represents final amount procured, ‘P’ represents principal, ‘r’ represents annual interest rate, ‘n’ represents the number of times that interest has been compounded, ‘t’ represents the tenure."
  },
  {
    "objectID": "tasks.html#послідовності",
    "href": "tasks.html#послідовності",
    "title": "[-] Задачі для самостійної підготовки",
    "section": "Послідовності",
    "text": "Послідовності"
  },
  {
    "objectID": "tasks.html#функції",
    "href": "tasks.html#функції",
    "title": "[-] Задачі для самостійної підготовки",
    "section": "Функції",
    "text": "Функції"
  },
  {
    "objectID": "tasks.html#читаннязапис-даних",
    "href": "tasks.html#читаннязапис-даних",
    "title": "[-] Задачі для самостійної підготовки",
    "section": "Читання/запис даних",
    "text": "Читання/запис даних"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Список використаних джерел",
    "section": "",
    "text": "Anaconda. The World’s Most Popular Data Science Platform. 2021.\n206 379 Broadway Ave., Suite 310 New York, NY 10013, USA: Anaconda Inc.\nhttps://www.anaconda.com/.\n\n\nChang, Winston, and Barbara Borges Ribeiro. 2021. Shinydashboard:\nCreate Dashboards with ’Shiny’. https://CRAN.R-project.org/package=shinydashboard.\n\n\nChang, Winston, Joe Cheng, JJ Allaire, Carson Sievert, Barret Schloerke,\nYihui Xie, Jeff Allen, Jonathan McPherson, Alan Dipert, and Barbara\nBorges. 2022. Shiny: Web Application Framework for r. https://CRAN.R-project.org/package=shiny.\n\n\nGoogle Colaboratory. 2021. Google LLC. https://colab.research.google.com/.\n\n\nKuhn, Max. 2022. Caret: Classification and Regression Training.\nhttps://CRAN.R-project.org/package=caret.\n\n\nLang, Michel, Martin Binder, Jakob Richter, Patrick Schratz, Florian\nPfisterer, Stefan Coors, Quay Au, Giuseppe Casalicchio, Lars Kotthoff,\nand Bernd Bischl. 2019. “mlr3: A\nModern Object-Oriented Machine Learning Framework in\nR.” Journal of Open Source Software,\nDecember. https://doi.org/10.21105/joss.01903.\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\n“R for Loop.” n.d. W3Schools. https://www.w3schools.com/r/r_for_loop.asp.\n\n\nRStudio Official Website. 2021. 250 Northern Ave, Boston, MA\n02210: RStudio, PBC. https://rstudio.com/.\n\n\nsabir. n.d. “R Repeat Loop.” R-Bloggers.com. https://www.r-bloggers.com/2022/07/r-repeat-loop/.\n\n\nSievert, Carson, Richard Iannone, JJ Allaire, and Barbara Borges. 2022.\nFlexdashboard: R Markdown Format for Flexible Dashboards. https://CRAN.R-project.org/package=flexdashboard.\n\n\nVisual Studio Code. 2021. Microsoft. https://code.visualstudio.com/.\n\n\nVisual Studio Community Edition. 2021. Microsoft. https://visualstudio.microsoft.com/.\n\n\nXie, Yihui. 2015. Dynamic Documents with R and\nKnitr. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. https://yihui.org/knitr/.\n\n\nXie, Yihui, Christophe Dervieux, and Emily Riederer. 2020. R\nMarkdown Cookbook. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown-cookbook."
  },
  {
    "objectID": "08-r-basic-types.html#перевірка-та-приведення-типів-даних",
    "href": "08-r-basic-types.html#перевірка-та-приведення-типів-даних",
    "title": "\n8  Базові типи даних R\n",
    "section": "\n8.2 Перевірка та приведення типів даних",
    "text": "8.2 Перевірка та приведення типів даних\nУ випадку коли тип даних потрібно визначити у процесі виконання програми/коду та перетворити значення використовується приведння типів даних.\nПриведення типів даних - операція перетворення значення з одного типу даних в інший. Важливо памятати, що не завжди приведення типів даних може бути здійснено. Так, наприклад, значення \"5\" (character) можна досить просто привести до 5 (numeric), проте \"five\" не буде зрозумілим для інтерпритатора.\nДля перевірки належності елемента до певного типу даних використовують спеціальну функцію is.назва_типу(значення). Ця функція повертає TRUE, якщо елемент належить даному типу і FALSE, якщо не належить.\nРозглянемо приклад:\n\nmy_numeric <- 5\nmy_character <- \"five\"\nmy_logical <- FALSE\n\nis.numeric(my_numeric)\n\n[1] TRUE\n\nis.character(my_numeric)\n\n[1] FALSE\n\n\nДля перетворення типу даних можна скористатися функцією as.назва_типу(значення). У результаті виконання функції буде повернуто значення потрібного типу або пусте значення NA, якщо таке приведення не є можливим:\n\na <- 5\nb <- \"10\"\nc <- \"10, 20\"\nas.numeric(b)\n\n[1] 10\n\nas.numeric(c)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\nРезультат виконання функцій можна записувати у змінні і використовувати у наступних обчисленнях:\n\na <- 5\nb <- \"10\"\nb <- as.numeric(b)\na + b\n\n[1] 15\n\n\n\nnumber <- as.integer(54)\ntypeof(number)\n\n[1] \"integer\"\n\nclass(number)\n\n[1] \"integer\"\n\n\nПовний перелік типів та методів перевірки і приведення їх типів ображений нижче:\n\nБазові типи даних R, методи перевірки та приведення\n\nНазва типу\nМетод перевірки типу\nМетод приведення типу\n\n\n\nArray\nis.array()\nas.array()\n\n\nCharacter\nis.character()\nas.character()\n\n\nComplex\nis.complex()\nas.complex()\n\n\nDataframe\nis.data.frame()\nas.data.frame()\n\n\nDouble\nis.double()\nas.double()\n\n\nFactor\nis.factor()\nas.factor()\n\n\nList\nis.list()\nas.list()\n\n\nLogical\nis.logical()\nas.logical()\n\n\nMatrix\nis.matrix()\nas.matrix()\n\n\nNumeric\nis.numeric()\nas.numeric()\n\n\nRaw\nis.raw()\nas.raw()\n\n\nTime series (ts)\nis.ts()\nas.ts()\n\n\nVector\nis.vector()\nas.vector()"
  },
  {
    "objectID": "14-r-vectors.html",
    "href": "14-r-vectors.html",
    "title": "14  Вектори [EN]",
    "section": "",
    "text": "This content is about variables, data types and basic operators in R."
  },
  {
    "objectID": "14-r-vectors.html#vectors",
    "href": "14-r-vectors.html#vectors",
    "title": "14  Вектори",
    "section": "14.1 Vectors",
    "text": "14.1 Vectors\n\n14.1.1 Announcement of vectors\nA vector is a base data type in R that allows you to write a collection of elements of the same type with or without c()if it is a sequence of values.\nNote. In essence, the function c() allows you to combine several vectors.\nConsider for example the usual variable x:\n\nx <- 10\n\nIn essence, x in this case is a vector consisting of one value of10. We can also write several elements to the variable x:\n\nx <- c(1, 2, 2.5, 3)\nx\n\n\n122.53\n\n\nVector elements can be values of any type: numeric,character, logical, etc .:\n\nv1 <- c(1, 3, 4, 6, 7)\nv2 <- c(T, F, F, T, F)\nv3 <- c(\"Hello\", \"my\", \"friend\", \"!\")\n\nVector elements are also sequences created using the functions rep (), seq () and the operator ::\n\nvtr <-  2:7\nvtr\nvtr <- 7:2\nvtr\n\n\n234567\n\n\n\n765432\n\n\nIf you need to combine several vectors, use the c() function:\n\nx <- 2:3\ny <- c(4,6,9)\nz <- c(x, y, 10:12, 100)\nz\n\n\n23469101112100\n\n\nYou can view brief descriptive statistics by vector using the ** summary() ** function:\n\nsummary(z)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   2.00    4.00    9.00   17.44   11.00  100.00 \n\n\n\n\n\n14.1.2 Operations on vectors\nThe advantage of using vectors over writing each value in a separate variable is the ability to perform 1 operation on all elements of the vector or on several vectors simultaneously, for example, arithmetic operations of addition or multiplication.\n\nv1 <- c(1, 3, 5)\nv1\nv1 * 10\n\n\n135\n\n\n\n103050\n\n\nFrom the example described above, it can be understood that the addition operation is essentially a superelement sum of vectors when the 1st element of the vector v1 is added to the 1st element of the vectorv2(1 + 2) and so on. Thus, the resulting vector will have the same length as the vectors v1 andv2.\nHowever, there may be a situation when one of the vectors has a shorter length or even consists of 1 element:\n\nv1 <- c(1, 3, 5, 7)\nv2 <- c(2, 4)\nv1 + v2\n\n\n37711\n\n\nIn this case, the number 2 will be added to each element of the vectorv1. In fact, this means that the vector v2 will look like c 2, 2), ie there will be a duplication of values to the length of the vectorv1 and then perform the operation of adding elements. Thus, the resulting vector will have the length of the longest of the vectors.\nConsider a more complex case where there are vectors with different numbers of elements other than 1:\n\nv1 <- c(2, 3)\nv2 <- c(4, 5, 6, 7)\nv3 <- c(1, 8, 9)\nv1 + v2 + v3\n\n\n7161711\n\n\nTo begin with, it should be noted that the interpreter warns that the lengths of the vectors are not multiples (if they were vectors of length 2, 4, 8, then there would be no warning).\nIf you extend each vector to the length of the maximum of them, repeating the elements cyclically, you get a set (marked added elements):\nv1 <- c(2, 3,*2,*3)\nv2 <- c(4, 5, 6, 7)\nv3 <- c(1, 8, 9,*1)\nSubtraction (-), division(/) and multiplication (*) operations are performed similarly.\nThe relation operators and logical operators also act element by element with respect to the vector, but the result is a collection (vector) of values of the logical type logical with the valuesTRUE/FALSE.\nConsider an example of finding all elements of the array v1 that are greater than the corresponding index elements of the arrayv2:\n\nv1 <- c(2, 4, 7, 9, 12)\nv2 <- c(6, 4, 6, 7, 1)\nv1 > v2\n\n\nFALSEFALSETRUETRUETRUE\n\n\nIn essence, as a result of execution there is a comparison of each element of both vectors among themselves: 2>6,4>4, 7>6,9>7, 12>1.\nTherefore, the previously studied operators (arithmetic, logical, relations) can be used to work with vectors as well.\n\n\n14.1.3 Naming vector elements\nIn order to understand what vectors mean and what data is often described, analysts need to sign this data.\nWe will write down information about daily visits to the site by users during the week in the following way:\n\n# Count of unique bank branch visits from Monday to Sunday\ndata <- c(1245, 2112, 1321, 1231, 2342, 1718, 1980)\n\nNext, assign values to the days of the week using the names () function:\n\nnames(data) <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\nprint(data)\n\n   Monday   Tuesday Wednesday  Thursday    Friday  Saturday    Sunday \n     1245      2112      1321      1231      2342      1718      1980 \n\n\nOtherwise, this code could be written as follows:\n\ndata <- c(1245, 2112, 1321, 1231, 2342, 1718, 1980)\ndays <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\nnames(data) <- days\ndata\n\nMonday1245Tuesday2112Wednesday1321Thursday1231Friday2342Saturday1718Sunday1980\n\n\nIf we need to get information, for example, about the name of the 4th element of the vector, we can use the code:\n\nnames(data)\n\n\n'Monday''Tuesday''Wednesday''Thursday''Friday''Saturday''Sunday'\n\n\nThe names () function allows not only to set the values of names for vector elements, but also to obtain information about them.\n\n\n\n14.1.4 Access to vector elements\nIndexing of elements inside the wind occurs from 1 ton, where n is the number of elements of the vector.\n\n  Note. In R, the indexing of array, vector, and all other collection types begins with 1, not with 0.\n\nConsider the previous example:\n\ndata <- c(1245, 2112, 1321, 1231, 2342, 1718, 1980)\ndays <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\nnames(data) <- days\n\nIn order to record information only about site visitors on Wednesday, you need to use the operator [] and specify the index of the element in the array:\n\ndata[3]\ndata[names(data) == 'Wednesday']\n\nWednesday: 1321\n\n\nWednesday: 1321\n\n\nIf there is a need to get several elements of the vector that are out of order, you can do it like this:\n\nsome_days <- data[c(1, 2, 5)]\nsome_days\n\nMonday1245Tuesday2112Friday2342\n\n\nFrom the example above it is clear that the indices of the vector data are another vector c(1, 2, 5), so it can be declared as a separate variable:\n\nindexes <- c(1, 2, 5)\nsome_days <- data[indexes]\nsome_days\n\nMonday1245Tuesday2112Friday2342\n\n\nIf there is a need to obtain information about several elements that are placed in a row, then for convenience (and in the case when such an array consists, for example, of 1000+ elements) use the operator :, for example:\n\nworking_days <- data[1:5]\nworking_days\n\nMonday1245Tuesday2112Wednesday1321Thursday1231Friday2342\n\n\nThus, all working days of the week are selected for the working_days vector.\n\n\n\n14.1.5 Useful functions\nLet’s take a look at some useful features that will simplify working with vectors. For further calculations we will use two vectors A andB:\n\nA <- c(3, 5, 8, 2, 5, 4, 2)\nB <- c(3, NA, 1, NA, 6, 4, 5)\nA\nB\n\n\n3582542\n\n\n\n3<NA>1<NA>645\n\n\n  Function sum(). This function is used to find the sum of the elements of the collection:\n\nsum(A)\nsum(B)\n\n29\n\n\n<NA>\n\n\nAn interesting point is that in the presence of gaps in the data (value NA) the calculation of the amount is impossible. In this case, the functions can take the additional parameter na.rm = T, whereT is an abbreviation of TRUE, which indicates the need to remove gaps in the data before performing the operation.\nNote. You should check the documentation for such a parameter in the function. If it is not present, then it is necessary to carry out cleaning in other ways before work with the data.\n\nsum(B, na.rm = T)\n\n19\n\n\n  The mean () function is used to find the arithmetic mean of numbers:\n\nmean(A)\nmean(B, na.rm = T)\n\n4.14285714285714\n\n\n3.8\n\n\n  min () and max () functions allow you to find the minimum and maximum values, respectively:\n\nmin(A)\nmax(A)\n\n2\n\n\n8\n\n\nAlso to work in R there is a large number of built-in implemented functions to perform statistical, econometric and other research in the field of economics and beyond. Try the sd(), cov(), cor() functions.\n  The length () function helps to determine the “length” of a vector, ie the number of elements:\n\nlength(A)\nlength(B)\n\n7\n\n\n7\n\n\n  The unique () function identifies unique elements in an array:\n\nA\nunique(A)\n\nprint(\"---\")\n\nB\nunique(B)\n\n\n3582542\n\n\n\n35824\n\n\n[1] \"---\"\n\n\n\n3<NA>1<NA>645\n\n\n\n3<NA>1645\n\n\n  The intersect() function allows you to find common elements of two vectors, so for vectors A andB common values are 3, 4 and5:\n\nA\nB\nintersect(A, B)\n\n\n3582542\n\n\n\n3<NA>1<NA>645\n\n\n\n354\n\n\nConversely,   The union() function allows you to combine elements of both sets / vectors:\n\nA\nB\nunion(A, B)\n\n\n3582542\n\n\n\n3<NA>1<NA>645\n\n\n\n35824<NA>16\n\n\nTry to understand the operation of the functions setdiff(), setequal(), is.element().\nI recommend reading the short materials here: https://stat.ethz.ch/R-manual/R-devel/library/base/html/sets.html.\n\n\n\n14.1.6 Correction of data (NA, NaN, Inf)\nIn the process of working with data there are problems associated with the correctness of their reading, conversion and operations on them. For example, an incorrect entry in the field of integer type \" +10 \" instead of 10 may result in conversion toNaN or division by 0 toInf.\nBefore using numerical and other data, the stage of cleaning and replacement of values is usually performed depending on the tasks of programming / research. In R the following types of the missed values are possible:\n\nNA ** - Not Available.\nNaN ** - Not a Number.\nInf ** - Infinity (infinity, can be with the sign+and-).\n\nLet’s start with vector:\n\nvtr <- c(1, -2, NA, NaN, Inf, 1223, -Inf, NA, 21) \nvtr\n\n\n1-2<NA>NaNInf1223-Inf<NA>21\n\n\nYou can check a single value for a space with the functions is.na(), is.nan(), is.infinite(), is.finite().\n\nis.na(vtr)\nis.nan(vtr)\nis.infinite(vtr)\nis.finite(vtr) # if infinite == TRUE => finite == FALSE :)\n\n\nFALSEFALSETRUETRUEFALSEFALSEFALSETRUEFALSE\n\n\n\nFALSEFALSEFALSETRUEFALSEFALSEFALSEFALSEFALSE\n\n\n\nFALSEFALSEFALSEFALSETRUEFALSETRUEFALSEFALSE\n\n\n\nTRUETRUEFALSEFALSEFALSETRUEFALSEFALSETRUE\n\n\nThen replacement of values can be executed as follows (we will replace all NA and Nan with 1000):\n\nvtr[is.na(vtr)] <- 1000\nvtr\n\n## Nan also replaced with is.na()!!!\n\n\n1-210001000Inf1223-Inf100021\n\n\nAnd then replace Inf with the maximum value in the vector, and -Inf with the minimum:\n\nvtr[is.nan(vtr)] <- 500\nvtr\n\nvtr[is.na(vtr)] <- 1000\nvtr\n\n## Nan also replaced with is.na()!!!\n\n\n1-210001000Inf1223-Inf100021\n\n\n\n1-210001000Inf1223-Inf100021\n\n\nAnd then replace Inf with the maximum value in the vector, and -Inf with the minimum:\n\nvtr <- c(1, -2, NA, NaN, Inf, 1223, -Inf, NA, 21) \nvtr\n\nis.infinite(vtr)\n!is.infinite(vtr)\nvtr[!is.infinite(vtr)]\nmax(vtr[!is.infinite(vtr)], na.rm = T)\n\nmax(vtr, na.rm = T)\nmin(vtr, na.rm = T)\n\nvtr[vtr == Inf] <- max(vtr)\nvtr[vtr == -Inf] <- min(vtr)\nvtr\n\n\n1-2<NA>NaNInf1223-Inf<NA>21\n\n\n\nFALSEFALSEFALSEFALSETRUEFALSETRUEFALSEFALSE\n\n\n\nTRUETRUETRUETRUEFALSETRUEFALSETRUETRUE\n\n\n\n1-2<NA>NaN1223<NA>21\n\n\n1223\n\n\nInf\n\n\n-Inf\n\n\n\n1-2<NA>NaN<NA>1223<NA><NA>21\n\n\nIf you want to replace the value in Inf regardless of the sign, you can useis.infinite().\n\n\n\n14.1.7 Tasks\n\n14.1.7.1 Task 1\n\nCreate vector of 10 random number in range \\([10;100]\\)\nReplace all odd (непарні) numbers with NA\nReplace all NA with average value\n\nSolution\n\nx <- sample(1:100, size = 10)\nx\n\n\n74423820289744877040\n\n\n\nx[x %% 2 != 0] <- NA\nx\n\n\n7442382028<NA>44<NA>7040\n\n\n\nx[is.na(x)] <- mean(x, na.rm = T)\nx\n\n\n744238202844.54444.57040"
  },
  {
    "objectID": "14-r-vectors.html#matrices",
    "href": "14-r-vectors.html#matrices",
    "title": "14  Вектори",
    "section": "14.2 Matrices",
    "text": "14.2 Matrices\n\n14.2.1 Creating matrices\nMatrix - a collection of elements of the same type (numeric,character, logical) with a fixed set of rows and columns. In the case where the matrix has only rows and columns, it is a two-dimensional data array.\nThe matrix is created using the matrix() function:\n\nmatrix(1:10, byrow = TRUE, nrow = 2)\n\n\n\nA matrix: 2 × 5 of type int\n\n    1234 5\n    678910\n\n\n\n\nwhere 1:10 - a set of elements of the matrix, it can also be a pre-formed vector (entered, by calculation, from a file, etc.),byrow = TRUE - means that the elements in the matrix will be written in rows, so in the pedestrian line contains the value 1:5, and the second6:10 (if we need to write information on the lines then we should use byrow = FASLE),nrow - the number of rows of the matrix.\n\nsales1 <- c(12, 14, 15)\nsales2 <- c(22, 15, 21)\nsales <- c(sales1, sales2)\nm <- matrix(sales, byrow= T, nrow = 2)\nm\n\n\n\nA matrix: 2 × 3 of type dbl\n\n    121415\n    221521\n\n\n\n\n\n\n\n14.2.2 Naming matrices\nTo specify the names of rows and columns of the matrix, use the functions rownames() and colnames():\n\nm <- matrix(1:9, nrow = 3)\nrownames(m) <- c(\"row1\", \"row2\", \"row3\")\ncolnames(m) <- c(\"c1\", \"c2\", \"c3\")\nm\n\n\n\nA matrix: 3 × 3 of type int\n\n    c1c2c3\n\n\n    row1147\n    row2258\n    row3369\n\n\n\n\n\n\n\n14.2.3 Add rows and columns\nSpecial methods cbind/rbind are used to change the number of elements in rows and columns of matrices, as well as to quickly combine them.\n ** The cbind ** function allows you to add one or more matrices and/or vectors behind one of the columns. That is, there is not a simple connection, but a comparison by key field. Consider an example:\n\nm1 <- matrix(c(1:3, 101:103), nrow = 3)\ncolnames(m1) <- c(\"A\", \"B\")\n\nm2 <- matrix(c(201:203, 1001:1003), nrow = 3)\ncolnames(m2) <- c(\"C\", \"D\")\n\nm_bind <- cbind(m1, m2)\n\nm1\nm2\nm_bind\n\n\n\nA matrix: 3 × 2 of type int\n\n    AB\n\n\n    1101\n    2102\n    3103\n\n\n\n\n\n\nA matrix: 3 × 2 of type int\n\n    CD\n\n\n    2011001\n    2021002\n    2031003\n\n\n\n\n\n\nA matrix: 3 × 4 of type int\n\n    ABCD\n\n\n    11012011001\n    21022021002\n    31032031003\n\n\n\n\n\n\n\n14.2.4 Access to matrix elements\nThe elements of the matrix are accessed by the index of rows and columns. You can select ranges in a similar way to vectors.\nLet’s look at an example:\n\nm <- matrix(11:25, nrow = 3)\nm\n\n\n\nA matrix: 3 × 5 of type int\n\n    1114172023\n    1215182124\n    1316192225\n\n\n\n\nTo display the 10th element of the matrix, you can use the entries (note that the account is from the right left corner of the columns):\n\nm[10]    \nm[[10]]\n\n20\n\n\n20\n\n\nTo display the same element using row and column indexes, write as follows:\n\n# Row #1\n# Column #4\nm[1,4]\n\n20\n\n\nQuestion: What record should you use ti get 18?\nAnswer: m[2,3]\n\nm[2,3]\n\n18\n\n\nIf you want to output / use an entire row or a whole column, then the block with the index of unnecessary dimensionality can be left blank:\n\nm[1, ] # first row only\nm[c(1,3), ] # first and third row only\n\n\n1114172023\n\n\n\n\nA matrix: 2 × 5 of type int\n\n    1114172023\n    1316192225\n\n\n\n\n\nm[, 1] # first column only\nm[, c(1,3)] # first and third column only\n\n\n111213\n\n\n\n\nA matrix: 3 × 2 of type int\n\n    1117\n    1218\n    1319\n\n\n\n\nYou can also specify a list of rows and columns to be output / received simultaneously:\n\nm[c(1,3), 2:4]\n\n\n\nA matrix: 2 × 3 of type int\n\n    141720\n    161922\n\n\n\n\nYou can exclude individual columns or rows by using indexes with minus signs (-):\n\nm[-1, c(-2:-3)]\n\n\n\nA matrix: 2 × 3 of type int\n\n    122124\n    132225\n\n\n\n\n\n\n\n14.2.5 Useful functions\n\n14.2.5.1 Matrix dimmentions\nTo obtain information about the dimensions of the table, there are special functions: nrow(), ncol(), dim():\n\n# Decalre matrix\nm <- matrix(1:15, ncol = 3)\nm\n\nprint(paste(\"Rows:\", nrow(m)))\nprint(paste(\"Cols:\", ncol(m)))\n\nprint(paste(\"Dim:\", paste0(dim(m), collapse = \" x \")))\n\n\n\nA matrix: 5 × 3 of type int\n\n    1 611\n    2 712\n    3 813\n    4 914\n    51015\n\n\n\n\n[1] \"Rows: 5\"\n[1] \"Cols: 3\"\n[1] \"Dim: 5 x 3\"\n\n\nUsing nrow() andncol() allows you to access the last row and column of the matrix, respectively:\n\nm[nrow(m), ] # last row\nm[, ncol(m)] # last colum\n\n\n51015\n\n\n\n1112131415"
  },
  {
    "objectID": "14-r-vectors.html#factors",
    "href": "14-r-vectors.html#factors",
    "title": "14  Вектори",
    "section": "14.3 Factors",
    "text": "14.3 Factors\nFactors in R programming allow you to represent a vector of values as categorical values, rather than just a set of text data or numbers. The advantage of the categorical data type is that the element can take only a limited number of values, and not any value that allows the data type.\nFor example, a numeric vector may contain an infinitely large variation of the values c(1, 0.021, 192.1444, ..., etc.), the character sets may also be different c (\"sdf & Tg6\",\"sdf * Y & 65\"). The number of combinations of such vectors is very large.\nIn the case of categories, we are talking about certain fixed values. A good example is forms that are filled out on sites with drop-down lists, where the user cannot enter a value, but only select from an existing list. So in the gender field there is usually a limited set of possible options: Male,Female, Other. The user can select only one of these values ​​and does not have the ability to enter something else (this is an example, each resource can make different forms for users).\nCreation of factors in R occurs by means of function factor():\n\ngender <- c(\"Male\", \"Female\", \"Other\", \"Male\", \"Female\", \"Male\", \"Female\", \"Female\")\ngender \ngender_factor <- factor(gender)\ngender_factor\n\n\n'Male''Female''Other''Male''Female''Male''Female''Female'\n\n\n\nMaleFemaleOtherMaleFemaleMaleFemaleFemale\n\n\n    \n        Levels:\n    \n    \n    'Female''Male''Other'\n\n\n\nWhen creating a factor, each unique element gets its own ** _ digital? _ ** _ (from the outside it looks like this, it needs to be clarified) _ value inside the collection, this value is called the level (level). In the previous example, the variable gender _factor received the levels Female, Male, Other in alphabetical order. If we convert factors to numbers, we get:\n\nas.numeric(gender_factor)\n\n\n21321211\n\n\ngender Thus it is clear that Female = 1, Male = 2, Other = 3. Consider a situation where we get data in which the order of values in the factor collection is different, for example, we need to specify so that Male = 1, Female = 2, Other = 3:\n\ngender <- c(\"Male\", \"Female\", \"Other\", \"Male\", \"Female\", \"Male\", \"Female\", \"Female\")\ngender_factor <- factor(gender, levels = c(\"Male\", \"Female\", \"Other\"))\ngender_factor\nlvl <- levels(gender_factor) # read levels of factor\nseq_along(lvl)\nas.integer(lvl)\nas.numeric(gender_factor)\n\n\nMaleFemaleOtherMaleFemaleMaleFemaleFemale\n\n\n    \n        Levels:\n    \n    \n    'Male''Female''Other'\n\n\n\n\n123\n\n\n\n<NA><NA><NA>\n\n\n\n12312122\n\n\nNow the order of the levels corresponds to ours and this will allow us to successfully combine our collection with similar ones that have the same set of values.\nSometimes it is necessary to change not only the order of the elements in the factorial collection, but also their names. Let’s consider a situation when we need to rename values Male,Female, Other inM, F,O:\n\ngender <- c(\"Male\", \"Female\", \"Other\", \"Male\", \"Female\", \"Male\", \"Female\", \"Female\")\ngender_factor <- factor(gender, levels = c(\"Male\", \"Female\", \"Other\"))\nlevels(gender_factor) <- c(\"M\", \"F\", \"O\")\ngender_factor\n\n\nMFOMFMFF\n\n\n    \n        Levels:\n    \n    \n    'M''F''O'\n\n\n\nBut you should check you type with is.factor() before converting to numbers:\n\ncities <- c(\"Rivne\", \"Ostroh\", \"Zdolbuniv\", \"Dubno\", \"Sarny\")\ncities_as_factors <- factor(cities)\nas.numeric(cities_as_factors)\nas.numeric(cities) # you cannot convert characters vector to numerics\n\n\n32514\n\n\n\n<NA><NA><NA><NA><NA>"
  },
  {
    "objectID": "14-r-vectors.html#dataframes",
    "href": "14-r-vectors.html#dataframes",
    "title": "14  Вектори",
    "section": "14.4 Dataframes",
    "text": "14.4 Dataframes\nData frames are the most popular data structure in R, becouse it allows collect data with different columns type in one object and quickly manipulate it.\nA data frame, a matrix-like structure whose columns may be of differing types (numeric, logical, factor and character and so on).\nThe function data.frame() creates data frames, tightly coupled collections of variables which share many of the properties of matrices and of lists, used as the fundamental data structure by most of R’s modeling software.\nSyntax\ndata.frame(..., row.names = NULL, check.rows = FALSE,\n           check.names = TRUE, fix.empty.names = TRUE,\n           stringsAsFactors = FALSE)\nArguments (top useful)\n\n... - these arguments are of either the form value or tag = value. Component names are created based on the tag (if present) or the deparsed argument itself.\nrow.names - NULL or a single integer or character string specifying a column to be used as row names, or a character or integer vector giving the row names for the data frame.\nstringsAsFactors - logical: should character vectors be converted to factors? The ‘factory-fresh’ default has been TRUE previously but has been changed to FALSE\n\nDetails\nA data frame is a list of variables of the same number of rows with unique row names, given class data.frame. If no variables are included, the row names determine the number of rows.\ndata.frame converts each of its arguments to a data frame by calling as.data.frame(optional = TRUE). As that is a generic function, methods can be written to change the behaviour of arguments according to their classes: R comes with many such methods. Character variables passed to data.frame are converted to factor columns unless protected argument stringsAsFactors is false. If a list or data frame or matrix is passed to data.frame it is as if each component or column had been passed as a separate argument.\n\n\n14.4.1 Creating Data Frames\nData frames are usually created by reading in a dataset from file, scraping from websites. However, data frames can also be created explicitly with the data.frame() function or they can be coerced from other types of objects like lists. In this case I’ll create a simple data frame df and assess its basic structure:\n\ndf <- data.frame(id = 1:5,\n                char_col = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                log_col = c(T,T,T,F,T),\n                double_col = c(2.1, 1, 0.5, pi, 12.7))\ndf\n\n\n\nA data.frame: 5 × 4\n\n    idchar_collog_coldouble_col\n    <int><chr><lgl><dbl>\n\n\n    1a TRUE 2.100000\n    2b TRUE 1.000000\n    3c TRUE 0.500000\n    4dFALSE 3.141593\n    5e TRUE12.700000\n\n\n\n\n\n# assess the structure of a data frame\nstr(df)\n\n'data.frame':   5 obs. of  4 variables:\n $ id        : int  1 2 3 4 5\n $ char_col  : chr  \"a\" \"b\" \"c\" \"d\" ...\n $ log_col   : logi  TRUE TRUE TRUE FALSE TRUE\n $ double_col: num  2.1 1 0.5 3.14 12.7\n\n\n\n# number of rows\nnrow(df)\n\n5\n\n\n\n# number of columns\nncol(df)\n\n4\n\n\nIf you want convert “on fly” character columns to factor use stringsAsFactors = TRUE:\n\ndf <- data.frame(i = 1:5,\n                char_col = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                log_col = c(T,T,T,F,T),\n                double_col = c(2.1, 1, 0.5, pi, 12.7),\n                stringsAsFactors = TRUE) # warning it depends on local settings of R\ndf\n\n\n\nA data.frame: 5 × 4\n\n    ichar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    1a TRUE 2.100000\n    2b TRUE 1.000000\n    3c TRUE 0.500000\n    4dFALSE 3.141593\n    5e TRUE12.700000\n\n\n\n\nCreating data.frames from lists (P.S. lists explained in next chapter):\nWe can create data.frame from vectors:\n\nv_int <- 1:5\nv_char <- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nv_log <- c(T,T,T,F,T)\nv_double <- c(2.1, 1, 0.5, pi, 12.7)\n\n\ndemo_list <- list(int_col = v_int,\n                  char_col = v_char,\n                  log_col = v_log,\n                  double_col = v_double)\nas.data.frame(demo_list)\n\n\n\nA data.frame: 5 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><chr><lgl><dbl>\n\n\n    1a TRUE 2.100000\n    2b TRUE 1.000000\n    3c TRUE 0.500000\n    4dFALSE 3.141593\n    5e TRUE12.700000\n\n\n\n\nMatrix can be base for data frame too:\n\ndemo_matrix <- matrix(100:119, nrow = 5, ncol = 4)\ndemo_matrix\n\nas.data.frame(demo_matrix)\n\n\n\nA matrix: 5 × 4 of type int\n\n    100105110115\n    101106111116\n    102107112117\n    103108113118\n    104109114119\n\n\n\n\n\n\nA data.frame: 5 × 4\n\n    V1V2V3V4\n    <int><int><int><int>\n\n\n    100105110115\n    101106111116\n    102107112117\n    103108113118\n    104109114119\n\n\n\n\n\n\n\n14.4.2 Extending data frames\nYou can add rows and columns to data frame. Merging two data frames by selected column values awailable too.\ncbind() adds new column\n\ndf <-  data.frame(A1 = c(\"A\", \"B\", \"C\"),\n                  A2 = c(\"D\", \"E\", \"F\"))\ndf\n\nA3 = c(1, 2, 3)\ncbind(df, A3)\n\n\ncolnames(df)\ncolnames(df) <- c(\"B1\", \"B2\")\ncolnames(df)\n\n\n\nA data.frame: 3 × 2\n\n    A1A2\n    <chr><chr>\n\n\n    AD\n    BE\n    CF\n\n\n\n\n\n\nA data.frame: 3 × 3\n\n    A1A2A3\n    <chr><chr><dbl>\n\n\n    AD1\n    BE2\n    CF3\n\n\n\n\n\n'A1''A2'\n\n\n\n'B1''B2'\n\n\nrbind() adds new row\n\nletters_frame <-  data.frame(A1 = c(\"A\", \"B\", \"C\"),\n                            A2 = 1:3)\nletters_frame\n\nnext_row = c(\"D\", 4) # data types by row should be the same as in initial data frame\nrbind(letters_frame, next_row)\n\n\n\nA data.frame: 3 × 2\n\n    A1A2\n    <chr><int>\n\n\n    A1\n    B2\n    C3\n\n\n\n\n\n\nA data.frame: 4 × 2\n\n    A1A2\n    <chr><chr>\n\n\n    A1\n    B2\n    C3\n    D4\n\n\n\n\n\n\n14.4.3 Merge DF\nData frames could me merged by key with merge():\n\ndf1 <- data.frame(Id = c(1:4),\n                  Name = c(\"Nick\", \"Jake\", \"Jane\", \"Mary\"))\ndf1\n\ndf2 <- data.frame(Id = c(2, 1, 3, 5), # defferent order from Id in df1\n                  Age = c(34, 21, 45, 20))\ndf2\n\ndf_final <- merge(df1, df2, by = \"Id\", all.x = F, all.y = F)\ndf_final\n\n\n\nA data.frame: 4 × 2\n\n    IdName\n    <int><chr>\n\n\n    1Nick\n    2Jake\n    3Jane\n    4Mary\n\n\n\n\n\n\nA data.frame: 4 × 2\n\n    IdAge\n    <dbl><dbl>\n\n\n    234\n    121\n    345\n    520\n\n\n\n\n\n\nA data.frame: 3 × 3\n\n    IdNameAge\n    <int><chr><dbl>\n\n\n    1Nick21\n    2Jake34\n    3Jane45\n\n\n\n\n\n\n\n14.4.4 Subsetting Data Frames\nData frames possess the characteristics of both lists and matrices: if you subset with a single vector, they behave like lists and will return the selected columns with all rows; if you subset with two vectors, they behave like matrices and can be subset by row and column:\n\ndf <- data.frame(int_col = 1:5,\n                char_col = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n                log_col = c(T,T,T,F,T),\n                double_col = c(2.1, 1, 0.5, pi, 12.7),\n                row.names = paste0(\"row_\", 1:5), # setting row names \n                stringsAsFactors = TRUE) # warning it depends on local settings of R\ndf\n\n\n\nA data.frame: 5 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_11a TRUE 2.100000\n    row_22b TRUE 1.000000\n    row_33c TRUE 0.500000\n    row_44dFALSE 3.141593\n    row_55e TRUE12.700000\n\n\n\n\n\n# select columns using $ sign\ndf$log_col\n\n\nTRUETRUETRUEFALSETRUE\n\n\n\n# subsetting by row numbers\ndf[1, ] # first row\ndf[nrow(df), ] # last row\ndf[-1, ] # all except first row\n\n\n\nA data.frame: 1 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_11aTRUE2.1\n\n\n\n\n\n\nA data.frame: 1 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_55eTRUE12.7\n\n\n\n\n\n\nA data.frame: 4 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_22b TRUE 1.000000\n    row_33c TRUE 0.500000\n    row_44dFALSE 3.141593\n    row_55e TRUE12.700000\n\n\n\n\n\n# subsetting by row names\ndf[c(\"row_4\", \"row_5\"), ]\n\n\n\nA data.frame: 2 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_44dFALSE 3.141593\n    row_55e TRUE12.700000\n\n\n\n\n\n# subsetting columns like a list\ndf[, c(\"log_col\", \"double_col\")]\n\n\n\nA data.frame: 5 × 2\n\n    log_coldouble_col\n    <lgl><dbl>\n\n\n    row_1 TRUE 2.100000\n    row_2 TRUE 1.000000\n    row_3 TRUE 0.500000\n    row_4FALSE 3.141593\n    row_5 TRUE12.700000\n\n\n\n\n\n# subset for both rows and columns\ndf[2:5, c(1, 3:4)]\n\n\n\nA data.frame: 4 × 3\n\n    int_collog_coldouble_col\n    <int><lgl><dbl>\n\n\n    row_22 TRUE 1.000000\n    row_33 TRUE 0.500000\n    row_44FALSE 3.141593\n    row_55 TRUE12.700000\n\n\n\n\nYou can also subset data frames based on conditional statements\n\n# select only with log_col == TRUE\ndf[df$double_col > 1, ]\n\ndf[!df$log_col, ]\n\n\n\nA data.frame: 3 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_11a TRUE 2.100000\n    row_44dFALSE 3.141593\n    row_55e TRUE12.700000\n\n\n\n\n\n\nA data.frame: 1 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_44dFALSE3.141593\n\n\n\n\n\n\"s\" %in% c(\"s\", \"t\")\n\nTRUE\n\n\n\n# select only with char_col == 'a', 'e'\nchars <- df$char_col %in% c(\"a\", \"e\")\nchars\nsum(chars)\ndf[chars, ] # %in% operator for check multuiple values\n\n\nTRUEFALSEFALSEFALSETRUE\n\n\n2\n\n\n\n\nA data.frame: 2 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_11aTRUE 2.1\n    row_55eTRUE12.7\n\n\n\n\n\n# select only with double_col > 1 and log_col == TRUE\ndf[df$log_col == TRUE & df$double_col > 1, ]\n\n\n\nA data.frame: 2 × 4\n\n    int_colchar_collog_coldouble_col\n    <int><fct><lgl><dbl>\n\n\n    row_11aTRUE 2.1\n    row_55eTRUE12.7\n\n\n\n\n\n# select only specific columns with double_col > 1 and log_col == TRUE\ndf[df$log_col == TRUE & df$double_col > 1, c(\"log_col\", \"int_col\", \"double_col\")]\n\n\n\nA data.frame: 2 × 3\n\n    log_colint_coldouble_col\n    <lgl><int><dbl>\n\n\n    row_1TRUE1 2.1\n    row_5TRUE512.7\n\n\n\n\n\n\n\n14.4.5 Order data.frame\nLet’s use our previous sample data.frame but with unordered values:\n\ndf <- data.frame(int_col = c(1, 5, 3, 4, 2),\n                char_col = c(\"b\", \"a\", \"a\", \"d\", \"e\"),\n                log_col = c(T,T,T,F,T),\n                double_col = c(2.1, 1, 0.5, pi, 12.7),\n                row.names = paste0(\"row_\", 1:5), # setting row names \n                stringsAsFactors = TRUE) # warning it depends on local settings of R\ndf\n\n\n\nA data.frame: 5 × 4\n\n    int_colchar_collog_coldouble_col\n    <dbl><fct><lgl><dbl>\n\n\n    row_11b TRUE 2.100000\n    row_25a TRUE 1.000000\n    row_33a TRUE 0.500000\n    row_44dFALSE 3.141593\n    row_52e TRUE12.700000\n\n\n\n\nYou can use order() function for sorting data.frames.\n\n# sort by int_col\norder(df$char_col)\norder(df$int_col)\ndf[order(df$char_col),]\n\n\n23145\n\n\n\n15342\n\n\n\n\nA data.frame: 5 × 4\n\n    int_colchar_collog_coldouble_col\n    <dbl><fct><lgl><dbl>\n\n\n    row_25a TRUE 1.000000\n    row_33a TRUE 0.500000\n    row_11b TRUE 2.100000\n    row_44dFALSE 3.141593\n    row_52e TRUE12.700000\n\n\n\n\nUse - minus to sort descending\n\n# sort by double_col\n# rev\ndf[rev(order(df$int_col)), ]\n\n\n\nA data.frame: 5 × 4\n\n    int_colchar_collog_coldouble_col\n    <dbl><fct><lgl><dbl>\n\n\n    row_25a TRUE 1.000000\n    row_44dFALSE 3.141593\n    row_33a TRUE 0.500000\n    row_52e TRUE12.700000\n    row_11b TRUE 2.100000\n\n\n\n\nYou can also sor by multiple columns with order(column1, column2) or order(column1, -column2).\n\n\n\n14.4.6 Manipulating data.frames\ntypeconvert ifelse createnew columns (calculate age) ?lubridate missing remove missing replace\nedit with dataeditR\n\n\n\n14.4.7 Tasks on data.frames\n\n14.4.7.1 Task 1\nWrite a code evaluates $y = x^2 + e, where x is a random number in range [0; 1].\nPrint calculation result as data.frame with columns X, E, Y.\nUse plot() funtion to visualize X vs Y as line chart (type = l or b).\nSolution\n\n# initiate data.frame\ndf <- data.frame(X = 1:10,\n                 E = sample(5, 10, replace = T),\n                 Y = NA)\nhead(df)\n\n\n\nA data.frame: 6 × 3\n\n    XEY\n    <int><int><lgl>\n\n\n    114NA\n    221NA\n    332NA\n    443NA\n    552NA\n    662NA\n\n\n\n\n\ndf$Y <- with(df, X^2 + E)\nhead(df)\n\n\n\nA data.frame: 6 × 3\n\n    XEY\n    <int><int><dbl>\n\n\n    114 5\n    221 5\n    33211\n    44319\n    55227\n    66238\n\n\n\n\n\nplot(df$X, df$Y, type=\"l\", col = \"blue\")\n\n\n\n\n\n\n\n\n14.4.8 Task 2\n\nInstall package and load package ISLR\nSave dataset Credit into variable credit_data.\nCheck dataset structure with str() function.\nConvert Student status “yes/no” to 1/0\nOrder dataset by Rating descending\nFilter only Age > 50 with Rating > 400, how many records do you get?\nEvaluate average Income for Married = YES Married = NO with Age in range [20,30]\n7.1 Make the same for Age [30;40] Any conclusion?\n\nSolution\n\n# 1. install.package ISLR\n#install.packages(\"ISLR\")\nlibrary(ISLR)\n\n\n# 2. Save dataset `Credit` into variable `credit_data`.\ncredit_data <- ISLR::Credit\nhead(credit_data, 3)\n\n\n\nA data.frame: 3 × 12\n\n    IDIncomeLimitRatingCardsAgeEducationGenderStudentMarriedEthnicityBalance\n    <int><dbl><int><int><int><int><int><fct><fct><fct><fct><int>\n\n\n    11 14.891360628323411 Male No YesCaucasian333\n    22106.025664548338215FemaleYesYesAsian    903\n    33104.593707551447111 Male No No Asian    580\n\n\n\n\n\n# 3. Check dataset structure with `str()` function.\nstr(credit_data)\n\n'data.frame':   400 obs. of  12 variables:\n $ ID       : int  1 2 3 4 5 6 7 8 9 10 ...\n $ Income   : num  14.9 106 104.6 148.9 55.9 ...\n $ Limit    : int  3606 6645 7075 9504 4897 8047 3388 7114 3300 6819 ...\n $ Rating   : int  283 483 514 681 357 569 259 512 266 491 ...\n $ Cards    : int  2 3 4 3 2 4 2 2 5 3 ...\n $ Age      : int  34 82 71 36 68 77 37 87 66 41 ...\n $ Education: int  11 15 11 11 16 10 12 9 13 19 ...\n $ Gender   : Factor w/ 2 levels \" Male\",\"Female\": 1 2 1 2 1 1 2 1 2 2 ...\n $ Student  : Factor w/ 2 levels \"No\",\"Yes\": 1 2 1 1 1 1 1 1 1 2 ...\n $ Married  : Factor w/ 2 levels \"No\",\"Yes\": 2 2 1 1 2 1 1 1 1 2 ...\n $ Ethnicity: Factor w/ 3 levels \"African American\",..: 3 2 2 2 3 3 1 2 3 1 ...\n $ Balance  : int  333 903 580 964 331 1151 203 872 279 1350 ...\n\n\n\n# Convert Student status \"yes/no\" to 1/0\n\nhead(as.numeric(credit_data$Student) - 1)\n\ncredit_data$Student <- as.character(credit_data$Student) # convert to character first / factors\ncredit_data$Student <- ifelse(credit_data$Student == \"Yes\", 1, 0)\n\nhead(credit_data)\n\n\n010000\n\n\n\n\nA data.frame: 6 × 12\n\n    IDIncomeLimitRatingCardsAgeEducationGenderStudentMarriedEthnicityBalance\n    <int><dbl><int><int><int><int><int><fct><dbl><fct><fct><int>\n\n\n    11 14.891360628323411 Male 0YesCaucasian 333\n    22106.025664548338215Female1YesAsian     903\n    33104.593707551447111 Male 0No Asian     580\n    44148.924950468133611Female0No Asian     964\n    55 55.882489735726816 Male 0YesCaucasian 331\n    66 80.180804756947710 Male 0No Caucasian1151\n\n\n\n\n\n# 5. Order dataset by `Rating` descending\ncredit_data <- credit_data[order(-credit_data$Rating), ]\nhead(credit_data)\n\n\n\nA data.frame: 6 × 12\n\n    IDIncomeLimitRatingCardsAgeEducationGenderStudentMarriedEthnicityBalance\n    <int><dbl><int><int><int><int><int><fct><dbl><fct><fct><int>\n\n\n    324324182.7281391398249817 Male 0YesCaucasian       1999\n    29 29186.6341341494924114Female0YesAfrican American1809\n    356356180.68211966832258 8Female0YesAfrican American1405\n    86 86152.2981206682844112Female0YesAsian           1779\n    294294140.67211200817746 9 Male 0YesAfrican American1677\n    185185158.8891158980516217Female0YesCaucasian       1448\n\n\n\n\n\n# 6. Filter only `Age > 50` with `Rating > 400`\ncredict_data_filtered <- credit_data[credit_data$Age > 50 & credit_data$Rating > 400, ]\nhead(credict_data_filtered)\nnrow(credict_data_filtered)\n\n\n\nA data.frame: 6 × 12\n\n    IDIncomeLimitRatingCardsAgeEducationGenderStudentMarriedEthnicityBalance\n    <int><dbl><int><int><int><int><int><fct><dbl><fct><fct><int>\n\n\n    324324182.7281391398249817 Male 0YesCaucasian       1999\n    356356180.68211966832258 8Female0YesAfrican American1405\n    185185158.8891158980516217Female0YesCaucasian       1448\n    348348160.2311074875426917 Male 0No Caucasian       1192\n    175175121.8341067375035416 Male 0No African American1573\n    391391135.1181057874738115Female0YesAsian           1393\n\n\n\n\n73\n\n\n\n#7. Evaluate average `Income` for `Married = YES` `Married = NO` with age in rage [20,30]\n# 7.1 Make the same for Age [30;40]\nmarried <- with(credit_data, credit_data[(Age>=20 & Age <=30) & Married == \"Yes\", ])\nhead(married)\n\n\n\nA data.frame: 6 × 12\n\n    IDIncomeLimitRatingCardsAgeEducationGenderStudentMarriedEthnicityBalance\n    <int><dbl><int><int><int><int><int><fct><dbl><fct><fct><int>\n\n\n    11 1163.095811758943014 Male 0YesCaucasian       1407\n    11411469.251638647443012Female0YesAsian            768\n    45 4531.861637546932516Female0YesCaucasian       1120\n    19 1949.5706384448128 9Female0YesAsian            891\n    44 4436.929625744512414Female0YesAsian            976\n    15115163.931572843532814Female0YesAfrican American 581\n\n\n\n\n\nnot_married <- credit_data[credit_data$Age %in% c(20:30) & credit_data$Married == \"No\", ]\nhead(not_married)\n\n\n\nA data.frame: 6 × 12\n\n    IDIncomeLimitRatingCardsAgeEducationGenderStudentMarriedEthnicityBalance\n    <int><dbl><int><int><int><int><int><fct><dbl><fct><fct><int>\n\n\n    21221229.567530939732515 Male 0NoCaucasian       799\n    94 9416.479543538822616 Male 0NoAfrican American937\n    27227244.978486634713010Female0NoCaucasian       436\n    20620610.793387832182913 Male 0NoCaucasian       638\n    17917928.316439131622910Female0NoCaucasian       453\n    18618630.420444231613014Female0NoAfrican American450\n\n\n\n\n\nmean(married$Income) # is it better to be merried? :)\nmean(not_married$Income)\n\n35.25635\n\n\n25.1618333333333"
  },
  {
    "objectID": "14-r-vectors.html#lists",
    "href": "14-r-vectors.html#lists",
    "title": "14  Вектори",
    "section": "14.5 Lists",
    "text": "14.5 Lists\nLists are the R objects which contain elements of different types like − numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. List is created using list() function.\nBefore start lest see one more package for working with date lubridate. It has a lot of functions for date parsing, manipulating and other. Check it with:\n\n#install.packages(\"lubridate\")\n#??lubridate\n\nFor our sample we need function ymd() that parse charater date from format like “2012-10-25”.\n\nlibrary(lubridate)\ndate1 <- ymd(\"2021-05-25\")\ndate2 <- ymd(\"2021-05-27\")\n\ndate1\ndate2\n\n2021-05-25\n\n\n2021-05-27\n\n\nYou can also use ymdhms() to parse date and time correctly.\n\ndatetime <- ymd_hms(\"2021-05-25 11:05:12\", tz = \"UTC\") # wee need this for client transactions fix\ndatetime\n\n[1] \"2021-05-25 11:05:12 UTC\"\n\n\n\n14.5.1 Creating a List\nFollowing is an example to create a list containing vectors, strings, numbers and a logical values. Our list will describe a model of banks client:\n\n# initial values\nset.seed(1) # for fixing pseudo-random\nlibrary(lubridate)\n\nclient_name <- \"John Doe\"\nservices <- c(\"credit\", \"deposite\", \"online-app\")\nis_active <- TRUE\ntransactions <- data.frame(contract_id = sample(10000:99999, size = 2, replace = T),# random numbers\n                          datetime = c(ymd_hms(\"2021-05-25 11:05:12\"),\n                                      ymd_hms(\"2021-05-25 11:07:14\"),\n                                      ymd_hms(\"2021-05-25 11:08:02\"),\n                                      ymd_hms(\"2021-05-25 11:12:45\"),\n                                      ymd_hms(\"2021-05-25 11:47:00\"),\n                                      ymd_hms(\"2021-05-25 11:48:08\")),\n                         oper_type = sample(0:1, size=6, replace = T), # 1 for debet, 0 for credet\n                         amount = round(sample(1:1000, size = 6) + runif(6),2))   \n\n#change AMOUNT to minus for debet (opertype == 1 \ntransactions$amount <- ifelse(transactions$oper_type == 1, (-1)*transactions$amount, transactions$amount) \ntransactions\n\n\n\nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n\n\n# creating list of signle objects, vector and dataframe\nlist_data <- list(client_name, is_active, services, transactions)\nlist_data\n\n\n\n    'John Doe'\n    TRUE\n    \n'credit''deposite''online-app'\n\n    \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n\n\n\n\n\n14.5.2 Naming List Elements\nIts better to name elements in list:\n\nnames(list_data) <- c(\"ClientName\", \"IsActive\", \"Services\", \"Transactions\")\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n\n\n\nYou can extend list “on fly” with $:\n\nlist_data$ClientName\nlist_data$ClientId <- 11125489656\nlist_data\n\n'John Doe'\n\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n\n\n\n\n\n\n14.5.3 Accessing List Elements\nFor now every element can be viewed with index in [[]] or []:\n\n# access to list element\nlist_data[1]\ntypeof(list_data[1])\n\n$ClientName = 'John Doe'\n\n\n'list'\n\n\n\n# access to object\nlist_data[[1]]\ntypeof(list_data[[1]])\n\n'John Doe'\n\n\n'character'\n\n\nAccess by $ also anbled:\n\nlist_data$Transactions\n\n\n\nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n\n\n\n\n14.5.4 Manipulating List Elements\nLets continue using out list_data list.\n\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n\n\n\nWe can change data with [] and access with $ symbol.\n\n# changing clint name with index\nlist_data[1] <- \"New Name\"\nlist_data\n\n\n\n    $ClientName\n        'New Name'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n\n\n\n\n# changing data with $\nlist_data$ClientName = \"John Doe\"\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n\n\n\nYo can merge lists with c() function. Let’s create new list and attach it to the list_data:\n\nlist_2 <- list(Consultant = list(Name = \"David Cameron\", PhoneNum = \"+9562311855\"))\nlist_2\n\n$Consultant = \n    $Name\n        'David Cameron'\n    $PhoneNum\n        '+9562311855'\n\n\n\n\nlist_data <- c(list_data, list_2)\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n    $Consultant\n        \n    $Name\n        'David Cameron'\n    $PhoneNum\n        '+9562311855'\n\n\n\n\n\nWith unlist() you can convert a list to a vector.\n\nlist_demo <- list(1:10)\nlist_demo\nclass(list_demo)\ntypeof(list_demo)\n\n\n    \n12345678910\n\n\n\n\n'list'\n\n\n'list'\n\n\nlist_demo * 5 # error, you cannot use * for list\n\nError in list_demo * 5: non-numeric argument to binary operator Traceback:\n\n\n\nlapply(list_demo, function(c) c*5)\n\n\n    \n5101520253035404550\n\n\n\n\n\nvector_demo <- unlist(list_demo)\nvector_demo\nclass(vector_demo)\ntypeof(vector_demo)\n\n\n12345678910\n\n\n'integer'\n\n\n'integer'\n\n\n\nvector_demo * 5 # now it works\n\n\n5101520253035404550\n\n\n\n\n\n14.5.5 Tasks for Practice\n\n14.5.5.1 Task 1\nWrie a function that calculates sum, average, median, min, max of taken vector. Generate sample vector of 10 elements in \\([1;100]\\).\nSolution\n\nx <- sample(10:100, size = 10)\nprint(x)\n\n [1] 94 46 98 99 43 53 88 42 44 79\n\n\n\nvector_info <- function(vector) {\n  x <- list()\n  x$Sum <- sum(vector)\n  x$Mean <- mean(vector)\n  x$Median <- median(vector)\n  x$Min <- min(vector)\n  x$Max <- max(vector)\n  return(x)\n}\n\nvector_info(x)\nnames(vector_info(x))\n\n\n    $Sum\n        686\n    $Mean\n        68.6\n    $Median\n        66\n    $Min\n        42\n    $Max\n        99\n\n\n\n\n'Sum''Mean''Median''Min''Max'"
  },
  {
    "objectID": "14-r-vectors.html#apply-functions-family",
    "href": "14-r-vectors.html#apply-functions-family",
    "title": "14  Вектори",
    "section": "14.6 Apply functions family",
    "text": "14.6 Apply functions family\nYou can use a set of function for manipulating, accesing different data structures such as data.frame, list.\nThe apply() family pertains to the R base package and is populated with functions to manipulate slices of data from matrices, arrays, lists and dataframes in a repetitive way. These functions allow crossing the data in a number of ways and avoid explicit use of loop constructs. They act on an input list, matrix or array and apply a named function with one or several optional arguments.\nThe called function could be:\n\nAn aggregating function, like for example the mean, or the sum (that return a number or scalar);\nOther transforming or subsetting functions; and\nOther vectorized functions, which yield more complex structures like lists, vectors, matrices, and arrays.\n\nThe apply() functions form the basis of more complex combinations and helps to perform operations with very few lines of code. More specifically, the family is made up of the apply(), lapply(), sapply(), vapply(), mapply(), rapply(), and tapply() functions.\nUsing of any functions depends on the structure of the data that you want to operate on and the format of the output that you need.\n\n14.6.1 apply()\napply() operates on arrays (2D arrays are matrices).\nSyntax is next: apply(X, MARGIN, FUN, ...), where\n\nX is an array or a matrix if the dimension of the array is 2;\nMARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. Note that when you use the construct MARGIN=c(1,2), it applies to both rows and columns; and\nFUN, which is the function that you want to apply to the data. It can be any R function, including a User Defined Function (UDF).\n\n\n# create a matrix\n\nmatrix  <- matrix(10:29, ncol = 5, nrow = 4)\nmatrix\n\n\n\nA matrix: 4 × 5 of type int\n\n    1014182226\n    1115192327\n    1216202428\n    1317212529\n\n\n\n\n\n# find sums by col\napply(matrix, 2, sum)\n\n\n46627894110\n\n\nIt your turn. TASK. Calculate average value of all rows:\n\napply(matrix, 1, mean)\n\n\n18192021\n\n\n\n\n14.6.2 lapply()\nlapply() from apply() is:\n\nIt can be used for other objects like dataframes, lists or vectors; and\nThe output returned is a list (which explains the “l” in the function name), which has the same number of elements as the object passed to it.\n\n?lapply to check params of fucntion:\n\n# ?lapply\n\nLets create list of data.frames:\n\ndf_a <- data.frame(Value1 = 1:5, Value2 = 101:105)\ndf_a\ndf_b <- data.frame(Value1 = 11:15, Value2 = 201:205)\ndf_c <- data.frame(Value1 = 16:20, Value2 = 301:305)\ndf_c\n\nlapply(df_a$Value1, sum)\n\n\n\nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    1101\n    2102\n    3103\n    4104\n    5105\n\n\n\n\n\n\nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    16301\n    17302\n    18303\n    19304\n    20305\n\n\n\n\n\n    1\n    2\n    3\n    4\n    5\n\n\n\n\nlist_demo <- list(df_a, df_b, df_c)\nlist_demo\n\n\n\n    \nA data.frame: 5  2\n\n    Value1Value2\n    <int><int>\n\n\n    1101\n    2102\n    3103\n    4104\n    5105\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    11201\n    12202\n    13203\n    14204\n    15205\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    16301\n    17302\n    18303\n    19304\n    20305\n\n\n\n\n\n\n\n# lets select the 2nd row of each data frame\n\nlapply(list_demo, \"[\", , 2)\n# list_demo - data\n# \"[\" -  selection operator\n# row index\n# col index\n\n\n    \n101102103104105\n\n    \n201202203204205\n\n    \n301302303304305\n\n\n\n\nTASK. Its your turn. Select all 1st rows of dataframes\n\nlapply(list_demo, \"[\", 1,)\n\n\n\n    \nA data.frame: 1  2\n\n    Value1Value2\n    <int><int>\n\n\n    11101\n\n\n\n    \nA data.frame: 1 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    111201\n\n\n\n    \nA data.frame: 1 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    116301\n\n\n\n\n\n\nTASK. Its your turn. Select all 1st elements (1st row, 1st col)\n\nlapply(list_demo, \"[\", 1, 1)\n\n\n    1\n    11\n    16\n\n\n\nYou can apply function to all elemetns. Let’s make some names in lowercase\n\nnames_list <- list(\"John\", \"Jane\", \"Jake\", \"Jacob\")\nlower_names <- lapply(names_list, tolower) \nclass(lower_names)\n\n'list'\n\n\n\n\n14.6.3 sapplay()\nsapply() takes a list vector or dataframe as an input and returns the output in vector or matrix form. Lets use sapply() function in the previous example and check the result.\n\nsapply(names_list, tolower) \n\n\n'john''jane''jake''jacob'\n\n\nIt tries to simplify the output to the most elementary data structure that is possible. And indeed, sapply() is a ‘wrapper’ function for lapply().\nLet’s try to get every 1st element of 2nd row from out list_demo:\n\nlist_demo\n\n\n\n    \nA data.frame: 5  2\n\n    Value1Value2\n    <int><int>\n\n\n    1101\n    2102\n    3103\n    4104\n    5105\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    11201\n    12202\n    13203\n    14204\n    15205\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    16301\n    17302\n    18303\n    19304\n    20305\n\n\n\n\n\n\n\ndata <- sapply(list_demo, \"[\", 2,1)\ndata\nclass(data)\n\n\n21217\n\n\n'integer'\n\n\n\n# lest set simplify = FASLE\ndata <- sapply(list_demo, \"[\", 2,1, simplify =F)\ndata\nclass(data)\n\n\n    2\n    12\n    17\n\n\n\n'list'\n\n\n\n\n14.6.4 aggregate()\nThis function is from package stats. It often used for grouping data by some key. Its from apply family, but working in the same way. So, its good idea discuss it now.\nSyntax for data.frame:\naggregate(x,               # R object \\\n          by,              # List of variables (grouping elements) \\\n          FUN,             # Function to be applied for summary statistics\\\n          ...,             # Additional arguments to be passed to FUN\\\n          simplify = TRUE, # Whether to simplify results as much as possible or not\\\n          drop = TRUE)     # Whether to drop unused combinations of grouping values or not.\nSyntax for formula:\n# Formula aggregate(formula,             # Input formula \\           data,                # List or data frame where the variables are stored \\           FUN,                 # Function to be applied for summary statistics \\           ...,                 # Additional arguments to be passed to FUN \\           subset,              # Observations to be used (optional) \\           na.action = na.omit) # How to deal with NA values`\nLets use our credit_data from one of the previous tasks:\n\ncredit_data <- ISLR::Credit\nhead(credit_data)\n\n\n\nA data.frame: 6 × 12\n\n    IDIncomeLimitRatingCardsAgeEducationGenderStudentMarriedEthnicityBalance\n    <int><dbl><int><int><int><int><int><fct><fct><fct><fct><int>\n\n\n    11 14.891360628323411 Male No YesCaucasian 333\n    22106.025664548338215FemaleYesYesAsian     903\n    33104.593707551447111 Male No No Asian     580\n    44148.924950468133611FemaleNo No Asian     964\n    55 55.882489735726816 Male No YesCaucasian 331\n    66 80.180804756947710 Male No No Caucasian1151\n\n\n\n\nTASK 1. Calculate average Balance by Gender:\n\n# lets use formula syntax\nmean_age <- aggregate(Age ~ Gender, data = credit_data, mean)\nmean_age \n\nn <- names(mean_age)\nn[n == \"Age\"] = \"Mean Age\"\nnames(mean_age) = n\nmean_age\n\n\n\nA data.frame: 2 × 2\n\n    GenderAge\n    <fct><dbl>\n\n\n     Male 55.59585\n    Female55.73430\n\n\n\n\n\n\nA data.frame: 2 × 2\n\n    GenderMean Age\n    <fct><dbl>\n\n\n     Male 55.59585\n    Female55.73430\n\n\n\n\nTASK 2. Average Balance for Gender and Student status at the same time\n\ngroup_bal <- aggregate(Age ~ Gender + Married, data = credit_data, mean)\ngroup_bal\n\n\n\nA data.frame: 4 × 3\n\n    GenderMarriedAge\n    <fct><fct><dbl>\n\n\n     Male No 57.13158\n    FemaleNo 57.36709\n     Male Yes54.59829\n    FemaleYes54.72656\n\n\n\n\n\n14.6.4.1 Task 3\nTry get aggregated average Income by Age. Order final dat.frame by age and make a plot().\n\ngroup_inc <- aggregate(Income ~ Age + Gender, data = credit_data, mean)\nhead(group_inc, 10)\n\n\n\nA data.frame: 10 × 3\n\n    AgeGenderIncome\n    <int><fct><dbl>\n\n\n    124 Male25.97400\n    225 Male29.56700\n    326 Male16.47900\n    427 Male39.70500\n    528 Male33.01700\n    629 Male17.95850\n    730 Male35.10467\n    831 Male43.52567\n    932 Male33.71150\n    1033 Male39.39733\n\n\n\n\n\nlevels(group_inc$Gender)\nlevels(group_inc$Gender) <- c(\"Male\", \"Female\")\n\nm_data <- group_inc[group_inc$Gender == \"Male\", ]\nnrow(m_data)\n\nf_data <- group_inc[group_inc$Gender == \"Female\", ]\nnrow(f_data)\nwith(m_data, plot(Age, Income, type = \"l\", col=\"red\"))\nwith(f_data, lines(Age, Income, type = \"l\", col =\"blue\"))\n#plot(group_inc$Age, group_inc$Income, type = \"b\")\n\n\n' Male''Female'\n\n\n63\n\n\n62"
  },
  {
    "objectID": "14-r-vectors.html#references",
    "href": "14-r-vectors.html#references",
    "title": "14  Вектори [EN]",
    "section": "14.8 References",
    "text": "14.8 References\n\nThe Comprehensive R Archive NetworkRcran: Url: https://cran.r-project.org/\nRStudio official website. Url: https://rstudio.com/\nAnaconda official website. Url: https://www.anaconda.com/\nIntroduction to R. Datacamp interactive course. Url: https://www.datacamp.com/courses/free-introduction-to-r\nQuanargo. Introduction to R. Url: https://www.quantargo.com/courses/course-r-introduction\nR Coder Project. Begin your data science career with R language! Url: https://r-coder.com/\nR Core Team (2019). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria.URL https://www.R-project.org/.\nA.B. Shipunov, EM Baldin, P.A. Volkova, VG Sufiyanov. Visual statistics. We use R! - M .: DMK Press, 2012. - 298 p .: ill.\nAn Introduction to R. URL: https://cran.r-project.org/doc/manuals/r-release/R-intro.html\nR programming. https://www.datamentor.io/r-programming\nLearn R. R Functions. https://www.w3schools.com/r/r_functions.asp\nUC Business Analytics R Programming Guide. Managing Data Frames. http://uc-r.github.io/dataframes\nLearn R programming. R - Lists. https://www.tutorialspoint.com/r/r_lists.htm\nTutorial on the R Apply Family by Carlo Fanara. https://www.datacamp.com/community/tutorials/r-tutorial-apply-family"
  },
  {
    "objectID": "14-r-vectors.html#announcement-of-vectors",
    "href": "14-r-vectors.html#announcement-of-vectors",
    "title": "14  Вектори [EN]",
    "section": "14.1 Announcement of vectors",
    "text": "14.1 Announcement of vectors\nA vector is a base data type in R that allows you to write a collection of elements of the same type with or without c()if it is a sequence of values.\nNote. In essence, the function c() allows you to combine several vectors.\nConsider for example the usual variable x:\n\nx <- 10\n\nIn essence, x in this case is a vector consisting of one value of10. We can also write several elements to the variable x:\n\nx <- c(1, 2, 2.5, 3)\nx\n\n\n122.53\n\n\nVector elements can be values of any type: numeric,character, logical, etc .:\n\nv1 <- c(1, 3, 4, 6, 7)\nv2 <- c(T, F, F, T, F)\nv3 <- c(\"Hello\", \"my\", \"friend\", \"!\")\n\nVector elements are also sequences created using the functions rep (), seq () and the operator ::\n\nvtr <-  2:7\nvtr\nvtr <- 7:2\nvtr\n\n\n234567\n\n\n\n765432\n\n\nIf you need to combine several vectors, use the c() function:\n\nx <- 2:3\ny <- c(4,6,9)\nz <- c(x, y, 10:12, 100)\nz\n\n\n23469101112100\n\n\nYou can view brief descriptive statistics by vector using the ** summary() ** function:\n\nsummary(z)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   2.00    4.00    9.00   17.44   11.00  100.00"
  },
  {
    "objectID": "14-r-vectors.html#operations-on-vectors",
    "href": "14-r-vectors.html#operations-on-vectors",
    "title": "14  Вектори [EN]",
    "section": "14.2 Operations on vectors",
    "text": "14.2 Operations on vectors\nThe advantage of using vectors over writing each value in a separate variable is the ability to perform 1 operation on all elements of the vector or on several vectors simultaneously, for example, arithmetic operations of addition or multiplication.\n\nv1 <- c(1, 3, 5)\nv1\nv1 * 10\n\n\n135\n\n\n\n103050\n\n\nFrom the example described above, it can be understood that the addition operation is essentially a superelement sum of vectors when the 1st element of the vector v1 is added to the 1st element of the vectorv2(1 + 2) and so on. Thus, the resulting vector will have the same length as the vectors v1 andv2.\nHowever, there may be a situation when one of the vectors has a shorter length or even consists of 1 element:\n\nv1 <- c(1, 3, 5, 7)\nv2 <- c(2, 4)\nv1 + v2\n\n\n37711\n\n\nIn this case, the number 2 will be added to each element of the vectorv1. In fact, this means that the vector v2 will look like c 2, 2), ie there will be a duplication of values to the length of the vectorv1 and then perform the operation of adding elements. Thus, the resulting vector will have the length of the longest of the vectors.\nConsider a more complex case where there are vectors with different numbers of elements other than 1:\n\nv1 <- c(2, 3)\nv2 <- c(4, 5, 6, 7)\nv3 <- c(1, 8, 9)\nv1 + v2 + v3\n\n\n7161711\n\n\nTo begin with, it should be noted that the interpreter warns that the lengths of the vectors are not multiples (if they were vectors of length 2, 4, 8, then there would be no warning).\nIf you extend each vector to the length of the maximum of them, repeating the elements cyclically, you get a set (marked added elements):\nv1 <- c(2, 3,*2,*3)\nv2 <- c(4, 5, 6, 7)\nv3 <- c(1, 8, 9,*1)\nSubtraction (-), division(/) and multiplication (*) operations are performed similarly.\nThe relation operators and logical operators also act element by element with respect to the vector, but the result is a collection (vector) of values of the logical type logical with the valuesTRUE/FALSE.\nConsider an example of finding all elements of the array v1 that are greater than the corresponding index elements of the arrayv2:\n\nv1 <- c(2, 4, 7, 9, 12)\nv2 <- c(6, 4, 6, 7, 1)\nv1 > v2\n\n\nFALSEFALSETRUETRUETRUE\n\n\nIn essence, as a result of execution there is a comparison of each element of both vectors among themselves: 2>6,4>4, 7>6,9>7, 12>1.\nTherefore, the previously studied operators (arithmetic, logical, relations) can be used to work with vectors as well."
  },
  {
    "objectID": "14-r-vectors.html#naming-vector-elements",
    "href": "14-r-vectors.html#naming-vector-elements",
    "title": "14  Вектори [EN]",
    "section": "14.3 Naming vector elements",
    "text": "14.3 Naming vector elements\nIn order to understand what vectors mean and what data is often described, analysts need to sign this data.\nWe will write down information about daily visits to the site by users during the week in the following way:\n\n# Count of unique bank branch visits from Monday to Sunday\ndata <- c(1245, 2112, 1321, 1231, 2342, 1718, 1980)\n\nNext, assign values to the days of the week using the names () function:\n\nnames(data) <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\nprint(data)\n\n   Monday   Tuesday Wednesday  Thursday    Friday  Saturday    Sunday \n     1245      2112      1321      1231      2342      1718      1980 \n\n\nOtherwise, this code could be written as follows:\n\ndata <- c(1245, 2112, 1321, 1231, 2342, 1718, 1980)\ndays <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\nnames(data) <- days\ndata\n\nMonday1245Tuesday2112Wednesday1321Thursday1231Friday2342Saturday1718Sunday1980\n\n\nIf we need to get information, for example, about the name of the 4th element of the vector, we can use the code:\n\nnames(data)\n\n\n'Monday''Tuesday''Wednesday''Thursday''Friday''Saturday''Sunday'\n\n\nThe names () function allows not only to set the values of names for vector elements, but also to obtain information about them."
  },
  {
    "objectID": "14-r-vectors.html#access-to-vector-elements",
    "href": "14-r-vectors.html#access-to-vector-elements",
    "title": "14  Вектори [EN]",
    "section": "14.4 Access to vector elements",
    "text": "14.4 Access to vector elements\nIndexing of elements inside the wind occurs from 1 ton, where n is the number of elements of the vector.\n\n  Note. In R, the indexing of array, vector, and all other collection types begins with 1, not with 0.\n\nConsider the previous example:\n\ndata <- c(1245, 2112, 1321, 1231, 2342, 1718, 1980)\ndays <- c(\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\")\nnames(data) <- days\n\nIn order to record information only about site visitors on Wednesday, you need to use the operator [] and specify the index of the element in the array:\n\ndata[3]\ndata[names(data) == 'Wednesday']\n\nWednesday: 1321\n\n\nWednesday: 1321\n\n\nIf there is a need to get several elements of the vector that are out of order, you can do it like this:\n\nsome_days <- data[c(1, 2, 5)]\nsome_days\n\nMonday1245Tuesday2112Friday2342\n\n\nFrom the example above it is clear that the indices of the vector data are another vector c(1, 2, 5), so it can be declared as a separate variable:\n\nindexes <- c(1, 2, 5)\nsome_days <- data[indexes]\nsome_days\n\nMonday1245Tuesday2112Friday2342\n\n\nIf there is a need to obtain information about several elements that are placed in a row, then for convenience (and in the case when such an array consists, for example, of 1000+ elements) use the operator :, for example:\n\nworking_days <- data[1:5]\nworking_days\n\nMonday1245Tuesday2112Wednesday1321Thursday1231Friday2342\n\n\nThus, all working days of the week are selected for the working_days vector."
  },
  {
    "objectID": "14-r-vectors.html#useful-functions",
    "href": "14-r-vectors.html#useful-functions",
    "title": "14  Вектори [EN]",
    "section": "14.5 Useful functions",
    "text": "14.5 Useful functions\nLet’s take a look at some useful features that will simplify working with vectors. For further calculations we will use two vectors A andB:\n\nA <- c(3, 5, 8, 2, 5, 4, 2)\nB <- c(3, NA, 1, NA, 6, 4, 5)\nA\nB\n\n\n3582542\n\n\n\n3<NA>1<NA>645\n\n\n  Function sum(). This function is used to find the sum of the elements of the collection:\n\nsum(A)\nsum(B)\n\n29\n\n\n<NA>\n\n\nAn interesting point is that in the presence of gaps in the data (value NA) the calculation of the amount is impossible. In this case, the functions can take the additional parameter na.rm = T, whereT is an abbreviation of TRUE, which indicates the need to remove gaps in the data before performing the operation.\nNote. You should check the documentation for such a parameter in the function. If it is not present, then it is necessary to carry out cleaning in other ways before work with the data.\n\nsum(B, na.rm = T)\n\n19\n\n\n  The mean () function is used to find the arithmetic mean of numbers:\n\nmean(A)\nmean(B, na.rm = T)\n\n4.14285714285714\n\n\n3.8\n\n\n  min () and max () functions allow you to find the minimum and maximum values, respectively:\n\nmin(A)\nmax(A)\n\n2\n\n\n8\n\n\nAlso to work in R there is a large number of built-in implemented functions to perform statistical, econometric and other research in the field of economics and beyond. Try the sd(), cov(), cor() functions.\n  The length () function helps to determine the “length” of a vector, ie the number of elements:\n\nlength(A)\nlength(B)\n\n7\n\n\n7\n\n\n  The unique () function identifies unique elements in an array:\n\nA\nunique(A)\n\nprint(\"---\")\n\nB\nunique(B)\n\n\n3582542\n\n\n\n35824\n\n\n[1] \"---\"\n\n\n\n3<NA>1<NA>645\n\n\n\n3<NA>1645\n\n\n  The intersect() function allows you to find common elements of two vectors, so for vectors A andB common values are 3, 4 and5:\n\nA\nB\nintersect(A, B)\n\n\n3582542\n\n\n\n3<NA>1<NA>645\n\n\n\n354\n\n\nConversely,   The union() function allows you to combine elements of both sets / vectors:\n\nA\nB\nunion(A, B)\n\n\n3582542\n\n\n\n3<NA>1<NA>645\n\n\n\n35824<NA>16\n\n\nTry to understand the operation of the functions setdiff(), setequal(), is.element().\nI recommend reading the short materials here: https://stat.ethz.ch/R-manual/R-devel/library/base/html/sets.html."
  },
  {
    "objectID": "14-r-vectors.html#correction-of-data-na-nan-inf",
    "href": "14-r-vectors.html#correction-of-data-na-nan-inf",
    "title": "14  Вектори [EN]",
    "section": "14.6 Correction of data (NA, NaN, Inf)",
    "text": "14.6 Correction of data (NA, NaN, Inf)\nIn the process of working with data there are problems associated with the correctness of their reading, conversion and operations on them. For example, an incorrect entry in the field of integer type \" +10 \" instead of 10 may result in conversion toNaN or division by 0 toInf.\nBefore using numerical and other data, the stage of cleaning and replacement of values is usually performed depending on the tasks of programming / research. In R the following types of the missed values are possible:\n\nNA ** - Not Available.\nNaN ** - Not a Number.\nInf ** - Infinity (infinity, can be with the sign+and-).\n\nLet’s start with vector:\n\nvtr <- c(1, -2, NA, NaN, Inf, 1223, -Inf, NA, 21) \nvtr\n\n\n1-2<NA>NaNInf1223-Inf<NA>21\n\n\nYou can check a single value for a space with the functions is.na(), is.nan(), is.infinite(), is.finite().\n\nis.na(vtr)\nis.nan(vtr)\nis.infinite(vtr)\nis.finite(vtr) # if infinite == TRUE => finite == FALSE :)\n\n\nFALSEFALSETRUETRUEFALSEFALSEFALSETRUEFALSE\n\n\n\nFALSEFALSEFALSETRUEFALSEFALSEFALSEFALSEFALSE\n\n\n\nFALSEFALSEFALSEFALSETRUEFALSETRUEFALSEFALSE\n\n\n\nTRUETRUEFALSEFALSEFALSETRUEFALSEFALSETRUE\n\n\nThen replacement of values can be executed as follows (we will replace all NA and Nan with 1000):\n\nvtr[is.na(vtr)] <- 1000\nvtr\n\n## Nan also replaced with is.na()!!!\n\n\n1-210001000Inf1223-Inf100021\n\n\nAnd then replace Inf with the maximum value in the vector, and -Inf with the minimum:\n\nvtr[is.nan(vtr)] <- 500\nvtr\n\nvtr[is.na(vtr)] <- 1000\nvtr\n\n## Nan also replaced with is.na()!!!\n\n\n1-210001000Inf1223-Inf100021\n\n\n\n1-210001000Inf1223-Inf100021\n\n\nAnd then replace Inf with the maximum value in the vector, and -Inf with the minimum:\n\nvtr <- c(1, -2, NA, NaN, Inf, 1223, -Inf, NA, 21) \nvtr\n\nis.infinite(vtr)\n!is.infinite(vtr)\nvtr[!is.infinite(vtr)]\nmax(vtr[!is.infinite(vtr)], na.rm = T)\n\nmax(vtr, na.rm = T)\nmin(vtr, na.rm = T)\n\nvtr[vtr == Inf] <- max(vtr)\nvtr[vtr == -Inf] <- min(vtr)\nvtr\n\n\n1-2<NA>NaNInf1223-Inf<NA>21\n\n\n\nFALSEFALSEFALSEFALSETRUEFALSETRUEFALSEFALSE\n\n\n\nTRUETRUETRUETRUEFALSETRUEFALSETRUETRUE\n\n\n\n1-2<NA>NaN1223<NA>21\n\n\n1223\n\n\nInf\n\n\n-Inf\n\n\n\n1-2<NA>NaN<NA>1223<NA><NA>21\n\n\nIf you want to replace the value in Inf regardless of the sign, you can useis.infinite()."
  },
  {
    "objectID": "14-r-vectors.html#tasks",
    "href": "14-r-vectors.html#tasks",
    "title": "14  Вектори [EN]",
    "section": "14.7 Tasks",
    "text": "14.7 Tasks\n\n14.7.1 Task 1\n\nCreate vector of 10 random number in range \\([10;100]\\)\nReplace all odd (непарні) numbers with NA\nReplace all NA with average value\n\nSolution\n\nx <- sample(1:100, size = 10)\nx\n\n\n74423820289744877040\n\n\n\nx[x %% 2 != 0] <- NA\nx\n\n\n7442382028<NA>44<NA>7040\n\n\n\nx[is.na(x)] <- mean(x, na.rm = T)\nx\n\n\n744238202844.54444.57040"
  },
  {
    "objectID": "18-r-lists.html",
    "href": "18-r-lists.html",
    "title": "18  Списки [EN]",
    "section": "",
    "text": "Lists are the R objects which contain elements of different types like − numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. List is created using list() function.\nBefore start lest see one more package for working with date lubridate. It has a lot of functions for date parsing, manipulating and other. Check it with:\n\n#install.packages(\"lubridate\")\n#??lubridate\n\nFor our sample we need function ymd() that parse charater date from format like “2012-10-25”.\n\nlibrary(lubridate)\ndate1 <- ymd(\"2021-05-25\")\ndate2 <- ymd(\"2021-05-27\")\n\ndate1\ndate2\n\n2021-05-25\n\n\n2021-05-27\n\n\nYou can also use ymdhms() to parse date and time correctly.\n\ndatetime <- ymd_hms(\"2021-05-25 11:05:12\", tz = \"UTC\") # wee need this for client transactions fix\ndatetime\n\n[1] \"2021-05-25 11:05:12 UTC\""
  },
  {
    "objectID": "18-r-lists.html#creating-a-list",
    "href": "18-r-lists.html#creating-a-list",
    "title": "18  Списки [EN]",
    "section": "18.2 Creating a List",
    "text": "18.2 Creating a List\nFollowing is an example to create a list containing vectors, strings, numbers and a logical values. Our list will describe a model of banks client:\n\n# initial values\nset.seed(1) # for fixing pseudo-random\nlibrary(lubridate)\n\nclient_name <- \"John Doe\"\nservices <- c(\"credit\", \"deposite\", \"online-app\")\nis_active <- TRUE\ntransactions <- data.frame(contract_id = sample(10000:99999, size = 2, replace = T),# random numbers\n                          datetime = c(ymd_hms(\"2021-05-25 11:05:12\"),\n                                      ymd_hms(\"2021-05-25 11:07:14\"),\n                                      ymd_hms(\"2021-05-25 11:08:02\"),\n                                      ymd_hms(\"2021-05-25 11:12:45\"),\n                                      ymd_hms(\"2021-05-25 11:47:00\"),\n                                      ymd_hms(\"2021-05-25 11:48:08\")),\n                         oper_type = sample(0:1, size=6, replace = T), # 1 for debet, 0 for credet\n                         amount = round(sample(1:1000, size = 6) + runif(6),2))   \n\n#change AMOUNT to minus for debet (opertype == 1 \ntransactions$amount <- ifelse(transactions$oper_type == 1, (-1)*transactions$amount, transactions$amount) \ntransactions\n\n\n\nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n\n\n# creating list of signle objects, vector and dataframe\nlist_data <- list(client_name, is_active, services, transactions)\nlist_data\n\n\n\n    'John Doe'\n    TRUE\n    \n'credit''deposite''online-app'\n\n    \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21"
  },
  {
    "objectID": "18-r-lists.html#naming-list-elements",
    "href": "18-r-lists.html#naming-list-elements",
    "title": "18  Списки [EN]",
    "section": "18.3 Naming List Elements",
    "text": "18.3 Naming List Elements\nIts better to name elements in list:\n\nnames(list_data) <- c(\"ClientName\", \"IsActive\", \"Services\", \"Transactions\")\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n\n\n\nYou can extend list “on fly” with $:\n\nlist_data$ClientName\nlist_data$ClientId <- 11125489656\nlist_data\n\n'John Doe'\n\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656"
  },
  {
    "objectID": "18-r-lists.html#accessing-list-elements",
    "href": "18-r-lists.html#accessing-list-elements",
    "title": "18  Списки [EN]",
    "section": "18.4 Accessing List Elements",
    "text": "18.4 Accessing List Elements\nFor now every element can be viewed with index in [[]] or []:\n\n# access to list element\nlist_data[1]\ntypeof(list_data[1])\n\n$ClientName = 'John Doe'\n\n\n'list'\n\n\n\n# access to object\nlist_data[[1]]\ntypeof(list_data[[1]])\n\n'John Doe'\n\n\n'character'\n\n\nAccess by $ also anbled:\n\nlist_data$Transactions\n\n\n\nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21"
  },
  {
    "objectID": "18-r-lists.html#manipulating-list-elements",
    "href": "18-r-lists.html#manipulating-list-elements",
    "title": "18  Списки [EN]",
    "section": "18.5 Manipulating List Elements",
    "text": "18.5 Manipulating List Elements\nLets continue using out list_data list.\n\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n\n\n\nWe can change data with [] and access with $ symbol.\n\n# changing clint name with index\nlist_data[1] <- \"New Name\"\nlist_data\n\n\n\n    $ClientName\n        'New Name'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n\n\n\n\n# changing data with $\nlist_data$ClientName = \"John Doe\"\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n\n\n\nYo can merge lists with c() function. Let’s create new list and attach it to the list_data:\n\nlist_2 <- list(Consultant = list(Name = \"David Cameron\", PhoneNum = \"+9562311855\"))\nlist_2\n\n$Consultant = \n    $Name\n        'David Cameron'\n    $PhoneNum\n        '+9562311855'\n\n\n\n\nlist_data <- c(list_data, list_2)\nlist_data\n\n\n\n    $ClientName\n        'John Doe'\n    $IsActive\n        TRUE\n    $Services\n        \n'credit''deposite''online-app'\n\n    $Transactions\n        \nA data.frame: 6 × 4\n\n    contract_iddatetimeoper_typeamount\n    <int><dttm><int><dbl>\n\n\n    343872021-05-25 11:05:121-187.72\n    695202021-05-25 11:07:140 307.99\n    343872021-05-25 11:08:020 993.38\n    695202021-05-25 11:12:450 597.78\n    343872021-05-25 11:47:001-277.93\n    695202021-05-25 11:48:081-874.21\n\n\n\n    $ClientId\n        11125489656\n    $Consultant\n        \n    $Name\n        'David Cameron'\n    $PhoneNum\n        '+9562311855'\n\n\n\n\n\nWith unlist() you can convert a list to a vector.\n\nlist_demo <- list(1:10)\nlist_demo\nclass(list_demo)\ntypeof(list_demo)\n\n\n    \n12345678910\n\n\n\n\n'list'\n\n\n'list'\n\n\nlist_demo * 5 # error, you cannot use * for list\n\nError in list_demo * 5: non-numeric argument to binary operator Traceback:\n\n\n\nlapply(list_demo, function(c) c*5)\n\n\n    \n5101520253035404550\n\n\n\n\n\nvector_demo <- unlist(list_demo)\nvector_demo\nclass(vector_demo)\ntypeof(vector_demo)\n\n\n12345678910\n\n\n'integer'\n\n\n'integer'\n\n\n\nvector_demo * 5 # now it works\n\n\n5101520253035404550"
  },
  {
    "objectID": "18-r-lists.html#tasks",
    "href": "18-r-lists.html#tasks",
    "title": "18  Списки [EN]",
    "section": "18.6 Tasks",
    "text": "18.6 Tasks\n\n18.6.1 Task 1\nWrie a function that calculates sum, average, median, min, max of taken vector. Generate sample vector of 10 elements in \\([1;100]\\).\nSolution\n\nx <- sample(10:100, size = 10)\nprint(x)\n\n [1] 94 46 98 99 43 53 88 42 44 79\n\n\n\nvector_info <- function(vector) {\n  x <- list()\n  x$Sum <- sum(vector)\n  x$Mean <- mean(vector)\n  x$Median <- median(vector)\n  x$Min <- min(vector)\n  x$Max <- max(vector)\n  return(x)\n}\n\nvector_info(x)\nnames(vector_info(x))\n\n\n    $Sum\n        686\n    $Mean\n        68.6\n    $Median\n        66\n    $Min\n        42\n    $Max\n        99\n\n\n\n\n'Sum''Mean''Median''Min''Max'"
  },
  {
    "objectID": "18-r-lists.html#references",
    "href": "18-r-lists.html#references",
    "title": "18  Списки [EN]",
    "section": "18.7 References",
    "text": "18.7 References\n\nThe Comprehensive R Archive NetworkRcran: Url: https://cran.r-project.org/\nRStudio official website. Url: https://rstudio.com/\nAnaconda official website. Url: https://www.anaconda.com/\nIntroduction to R. Datacamp interactive course. Url: https://www.datacamp.com/courses/free-introduction-to-r\nQuanargo. Introduction to R. Url: https://www.quantargo.com/courses/course-r-introduction\nR Coder Project. Begin your data science career with R language! Url: https://r-coder.com/\nR Core Team (2019). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria.URL https://www.R-project.org/.\nA.B. Shipunov, EM Baldin, P.A. Volkova, VG Sufiyanov. Visual statistics. We use R! - M .: DMK Press, 2012. - 298 p .: ill.\nAn Introduction to R. URL: https://cran.r-project.org/doc/manuals/r-release/R-intro.html\nR programming. https://www.datamentor.io/r-programming\nLearn R. R Functions. https://www.w3schools.com/r/r_functions.asp\nUC Business Analytics R Programming Guide. Managing Data Frames. http://uc-r.github.io/dataframes\nLearn R programming. R - Lists. https://www.tutorialspoint.com/r/r_lists.htm\nTutorial on the R Apply Family by Carlo Fanara. https://www.datacamp.com/community/tutorials/r-tutorial-apply-family"
  },
  {
    "objectID": "19-r-apply-functions.html",
    "href": "19-r-apply-functions.html",
    "title": "19  Функції apply()",
    "section": "",
    "text": "Wrie a function that calculates sum, average, median, min, max of taken vector. Generate sample vector of 10 elements in \\([1;100]\\).\nSolution\n\nx <- sample(10:100, size = 10)\nprint(x)\n\n [1] 94 46 98 99 43 53 88 42 44 79\n\n\n\nvector_info <- function(vector) {\n  x <- list()\n  x$Sum <- sum(vector)\n  x$Mean <- mean(vector)\n  x$Median <- median(vector)\n  x$Min <- min(vector)\n  x$Max <- max(vector)\n  return(x)\n}\n\nvector_info(x)\nnames(vector_info(x))\n\n\n    $Sum\n        686\n    $Mean\n        68.6\n    $Median\n        66\n    $Min\n        42\n    $Max\n        99\n\n\n\n\n'Sum''Mean''Median''Min''Max'"
  },
  {
    "objectID": "19-r-apply-functions.html#apply-functions-family",
    "href": "19-r-apply-functions.html#apply-functions-family",
    "title": "19  Функції apply()",
    "section": "19.1 Apply functions family",
    "text": "19.1 Apply functions family\nYou can use a set of function for manipulating, accesing different data structures such as data.frame, list.\nThe apply() family pertains to the R base package and is populated with functions to manipulate slices of data from matrices, arrays, lists and dataframes in a repetitive way. These functions allow crossing the data in a number of ways and avoid explicit use of loop constructs. They act on an input list, matrix or array and apply a named function with one or several optional arguments.\nThe called function could be:\n\nAn aggregating function, like for example the mean, or the sum (that return a number or scalar);\nOther transforming or subsetting functions; and\nOther vectorized functions, which yield more complex structures like lists, vectors, matrices, and arrays.\n\nThe apply() functions form the basis of more complex combinations and helps to perform operations with very few lines of code. More specifically, the family is made up of the apply(), lapply(), sapply(), vapply(), mapply(), rapply(), and tapply() functions.\nUsing of any functions depends on the structure of the data that you want to operate on and the format of the output that you need.\n\n19.1.1 apply()\napply() operates on arrays (2D arrays are matrices).\nSyntax is next: apply(X, MARGIN, FUN, ...), where\n\nX is an array or a matrix if the dimension of the array is 2;\nMARGIN is a variable defining how the function is applied: when MARGIN=1, it applies over rows, whereas with MARGIN=2, it works over columns. Note that when you use the construct MARGIN=c(1,2), it applies to both rows and columns; and\nFUN, which is the function that you want to apply to the data. It can be any R function, including a User Defined Function (UDF).\n\n\n# create a matrix\n\nmatrix  <- matrix(10:29, ncol = 5, nrow = 4)\nmatrix\n\n\n\nA matrix: 4 × 5 of type int\n\n    1014182226\n    1115192327\n    1216202428\n    1317212529\n\n\n\n\n\n# find sums by col\napply(matrix, 2, sum)\n\n\n46627894110\n\n\nIt your turn. TASK. Calculate average value of all rows:\n\napply(matrix, 1, mean)\n\n\n18192021\n\n\n\n\n19.1.2 lapply()\nlapply() from apply() is:\n\nIt can be used for other objects like dataframes, lists or vectors; and\nThe output returned is a list (which explains the “l” in the function name), which has the same number of elements as the object passed to it.\n\n?lapply to check params of fucntion:\n\n# ?lapply\n\nLets create list of data.frames:\n\ndf_a <- data.frame(Value1 = 1:5, Value2 = 101:105)\ndf_a\ndf_b <- data.frame(Value1 = 11:15, Value2 = 201:205)\ndf_c <- data.frame(Value1 = 16:20, Value2 = 301:305)\ndf_c\n\nlapply(df_a$Value1, sum)\n\n\n\nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    1101\n    2102\n    3103\n    4104\n    5105\n\n\n\n\n\n\nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    16301\n    17302\n    18303\n    19304\n    20305\n\n\n\n\n\n    1\n    2\n    3\n    4\n    5\n\n\n\n\nlist_demo <- list(df_a, df_b, df_c)\nlist_demo\n\n\n\n    \nA data.frame: 5  2\n\n    Value1Value2\n    <int><int>\n\n\n    1101\n    2102\n    3103\n    4104\n    5105\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    11201\n    12202\n    13203\n    14204\n    15205\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    16301\n    17302\n    18303\n    19304\n    20305\n\n\n\n\n\n\n\n# lets select the 2nd row of each data frame\n\nlapply(list_demo, \"[\", , 2)\n# list_demo - data\n# \"[\" -  selection operator\n# row index\n# col index\n\n\n    \n101102103104105\n\n    \n201202203204205\n\n    \n301302303304305\n\n\n\n\nTASK. Its your turn. Select all 1st rows of dataframes\n\nlapply(list_demo, \"[\", 1,)\n\n\n\n    \nA data.frame: 1  2\n\n    Value1Value2\n    <int><int>\n\n\n    11101\n\n\n\n    \nA data.frame: 1 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    111201\n\n\n\n    \nA data.frame: 1 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    116301\n\n\n\n\n\n\nTASK. Its your turn. Select all 1st elements (1st row, 1st col)\n\nlapply(list_demo, \"[\", 1, 1)\n\n\n    1\n    11\n    16\n\n\n\nYou can apply function to all elemetns. Let’s make some names in lowercase\n\nnames_list <- list(\"John\", \"Jane\", \"Jake\", \"Jacob\")\nlower_names <- lapply(names_list, tolower) \nclass(lower_names)\n\n'list'\n\n\n\n\n19.1.3 sapplay()\nsapply() takes a list vector or dataframe as an input and returns the output in vector or matrix form. Lets use sapply() function in the previous example and check the result.\n\nsapply(names_list, tolower) \n\n\n'john''jane''jake''jacob'\n\n\nIt tries to simplify the output to the most elementary data structure that is possible. And indeed, sapply() is a ‘wrapper’ function for lapply().\nLet’s try to get every 1st element of 2nd row from out list_demo:\n\nlist_demo\n\n\n\n    \nA data.frame: 5  2\n\n    Value1Value2\n    <int><int>\n\n\n    1101\n    2102\n    3103\n    4104\n    5105\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    11201\n    12202\n    13203\n    14204\n    15205\n\n\n\n    \nA data.frame: 5 × 2\n\n    Value1Value2\n    <int><int>\n\n\n    16301\n    17302\n    18303\n    19304\n    20305\n\n\n\n\n\n\n\ndata <- sapply(list_demo, \"[\", 2,1)\ndata\nclass(data)\n\n\n21217\n\n\n'integer'\n\n\n\n# lest set simplify = FASLE\ndata <- sapply(list_demo, \"[\", 2,1, simplify =F)\ndata\nclass(data)\n\n\n    2\n    12\n    17\n\n\n\n'list'\n\n\n\n\n19.1.4 aggregate()\nThis function is from package stats. It often used for grouping data by some key. Its from apply family, but working in the same way. So, its good idea discuss it now.\nSyntax for data.frame:\naggregate(x,               # R object \\\n          by,              # List of variables (grouping elements) \\\n          FUN,             # Function to be applied for summary statistics\\\n          ...,             # Additional arguments to be passed to FUN\\\n          simplify = TRUE, # Whether to simplify results as much as possible or not\\\n          drop = TRUE)     # Whether to drop unused combinations of grouping values or not.\nSyntax for formula:\n# Formula aggregate(formula,             # Input formula \\           data,                # List or data frame where the variables are stored \\           FUN,                 # Function to be applied for summary statistics \\           ...,                 # Additional arguments to be passed to FUN \\           subset,              # Observations to be used (optional) \\           na.action = na.omit) # How to deal with NA values`\nLets use our credit_data from one of the previous tasks:\n\ncredit_data <- ISLR::Credit\nhead(credit_data)\n\nERROR: Error in loadNamespace(x): there is no package called 'ISLR'"
  },
  {
    "objectID": "19-r-apply-functions.html#tasks",
    "href": "19-r-apply-functions.html#tasks",
    "title": "19  Функції apply()",
    "section": "19.2 Tasks",
    "text": "19.2 Tasks\n\n19.2.1 TASK 1. Calculate average Balance by Gender:\n\n# lets use formula syntax\nmean_age <- aggregate(Age ~ Gender, data = credit_data, mean)\nmean_age \n\nn <- names(mean_age)\nn[n == \"Age\"] = \"Mean Age\"\nnames(mean_age) = n\nmean_age\n\n\n\nA data.frame: 2 × 2\n\n    GenderAge\n    <fct><dbl>\n\n\n     Male 55.59585\n    Female55.73430\n\n\n\n\n\n\nA data.frame: 2 × 2\n\n    GenderMean Age\n    <fct><dbl>\n\n\n     Male 55.59585\n    Female55.73430\n\n\n\n\n\n\n19.2.2 TASK 2. Average Balance for Gender and Student status at the same time\n\ngroup_bal <- aggregate(Age ~ Gender + Married, data = credit_data, mean)\ngroup_bal\n\n\n\nA data.frame: 4 × 3\n\n    GenderMarriedAge\n    <fct><fct><dbl>\n\n\n     Male No 57.13158\n    FemaleNo 57.36709\n     Male Yes54.59829\n    FemaleYes54.72656\n\n\n\n\n\n\n19.2.3 Task 3\nTry get aggregated average Income by Age. Order final dat.frame by age and make a plot().\n\ngroup_inc <- aggregate(Income ~ Age + Gender, data = credit_data, mean)\nhead(group_inc, 10)\n\n\n\nA data.frame: 10 × 3\n\n    AgeGenderIncome\n    <int><fct><dbl>\n\n\n    124 Male25.97400\n    225 Male29.56700\n    326 Male16.47900\n    427 Male39.70500\n    528 Male33.01700\n    629 Male17.95850\n    730 Male35.10467\n    831 Male43.52567\n    932 Male33.71150\n    1033 Male39.39733\n\n\n\n\n\nlevels(group_inc$Gender)\nlevels(group_inc$Gender) <- c(\"Male\", \"Female\")\n\nm_data <- group_inc[group_inc$Gender == \"Male\", ]\nnrow(m_data)\n\nf_data <- group_inc[group_inc$Gender == \"Female\", ]\nnrow(f_data)\nwith(m_data, plot(Age, Income, type = \"l\", col=\"red\"))\nwith(f_data, lines(Age, Income, type = \"l\", col =\"blue\"))\n#plot(group_inc$Age, group_inc$Income, type = \"b\")\n\n\n' Male''Female'\n\n\n63\n\n\n62"
  },
  {
    "objectID": "19-r-apply-functions.html#references",
    "href": "19-r-apply-functions.html#references",
    "title": "19  Функції apply()",
    "section": "19.3 References",
    "text": "19.3 References\n\nThe Comprehensive R Archive NetworkRcran: Url: https://cran.r-project.org/\nRStudio official website. Url: https://rstudio.com/\nAnaconda official website. Url: https://www.anaconda.com/\nIntroduction to R. Datacamp interactive course. Url: https://www.datacamp.com/courses/free-introduction-to-r\nQuanargo. Introduction to R. Url: https://www.quantargo.com/courses/course-r-introduction\nR Coder Project. Begin your data science career with R language! Url: https://r-coder.com/\nR Core Team (2019). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria.URL https://www.R-project.org/.\nA.B. Shipunov, EM Baldin, P.A. Volkova, VG Sufiyanov. Visual statistics. We use R! - M .: DMK Press, 2012. - 298 p .: ill.\nAn Introduction to R. URL: https://cran.r-project.org/doc/manuals/r-release/R-intro.html\nR programming. https://www.datamentor.io/r-programming\nLearn R. R Functions. https://www.w3schools.com/r/r_functions.asp\nUC Business Analytics R Programming Guide. Managing Data Frames. http://uc-r.github.io/dataframes\nLearn R programming. R - Lists. https://www.tutorialspoint.com/r/r_lists.htm\nTutorial on the R Apply Family by Carlo Fanara. https://www.datacamp.com/community/tutorials/r-tutorial-apply-family"
  }
]