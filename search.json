[
  {
    "objectID": "index.html#опис-навчальної-дисципліни",
    "href": "index.html#опис-навчальної-дисципліни",
    "title": "Вступ до програмування в R",
    "section": "Опис навчальної дисципліни",
    "text": "Опис навчальної дисципліни\nНавчальна дисципліна спрямована на вивчення основ практичного застосування популярної мови R для проведення статистичних досліджень в економіці.\nУ процесі вивчення курсу розглядаються теми, що стосуються теоретичних основ та практичної реалізації алгоритмів, завантаження, підготовки та обробки економічних даних.\nМісце навчальної дисципліни у підготовці здобувачів: програмні результати дисципліни використовуються під час вивчення таких навчальних дисциплін: “Алгоритми та структури даних”, “Аналіз даних в R”, “Прикладне математичне моделювання в R”, “Підготовка аналітичних звітів”. Закріплення на практиці здобутих програмних результатів відбувається під час проходження навчальної практики з курсу “Економіко-математичне моделювання”."
  },
  {
    "objectID": "index.html#мета-дисципліни",
    "href": "index.html#мета-дисципліни",
    "title": "Вступ до програмування в R",
    "section": "Мета дисципліни",
    "text": "Мета дисципліни\nМета навчальної дисципліни – формування у студентів теоретичних знань та практичних навичок використання мови програмування R для роботи з даними та базовими структурами мови (типи даних, розгалуження, цикли, функції)."
  },
  {
    "objectID": "index.html#рецензенти",
    "href": "index.html#рецензенти",
    "title": "Вступ до програмування в R",
    "section": "Рецензенти",
    "text": "Рецензенти\nЗовнішній рецензент\nSasha Talavera, Ph. D. in Economics, Professor of Financial Economics at the Department of Economics, Birmingham Business School, University of Birmingham.\nТекст рецензії\nВнутрішній рецензент\nАнатолій Нікітін, доктор фізико-математичних наук, доцент, професор кафедри економіко-математичного моделювання та інформаційних технологій Національного університету “Острозька академія”.\n\nТекст рецензії"
  },
  {
    "objectID": "index.html#підтримка-проєкту",
    "href": "index.html#підтримка-проєкту",
    "title": "Вступ до програмування в R",
    "section": "Підтримка проєкту",
    "text": "Підтримка проєкту\nМатеріали навчального посібника створено у межах проєкту “Підготовка, обробка та ефективне використання даних для наукових досліджень (на основі R)”, що підтримується Європейським союзою за програмою House of Europe."
  },
  {
    "objectID": "index.html#дотримання-принципів-доброчесності",
    "href": "index.html#дотримання-принципів-доброчесності",
    "title": "Вступ до програмування в R",
    "section": "Дотримання принципів доброчесності",
    "text": "Дотримання принципів доброчесності\nВикладач та слухач цього курсу, як очікується, повинні дотримуватися Кодексу академічної доброчесності університету:\n\nбудь-яка робота, подана здобувачем протягом курсу, має бути його власною роботою здобувача; не вдаватися до кроків, що можуть нечесно покращити Ваші результати чи погіршити/покращити результати інших здобувачів;\nякщо буде виявлено ознаки плагіату або іншої недобросовісної академічної поведінки, то студент буде позбавлений можливості отримати передбачені бали за завдання;\nне публікувати у відкритому доступі відповіді на запитання, що використовуються в рамках курсу для оцінювання знань здобувачів;\nпід час фінальних видів контролю необхідно працювати самостійно; не дозволяється говорити або обговорювати, а також не можна копіювати документи, використовувати електронні засоби отримання інформації.\n\nПорушення академічної доброчесності під час виконання контрольних завдань призведе до втрати балів або вживання заходів, які передбачені Кодексу академічної доброчесності НаУОА.\n\n\n\n\n\n\n\nМатеріали курсу створені з використанням ряду технологій та середовищ розробки:\n\nМова R - безкоштована мова програмування для виконання досліджень у сфері статистики, машинного навчання та візуалізацї результатів.\nQuarto Book - система для публікації наукових та технічних текстів з відкритим кодом (R/Python/Julia/Observable).\nJupyterLab - середовище розробки на основі Jupyter Notebook. JupyterLab є розширеним веб-інтерфейсом для роботи з ноутбуками.\nGit/Github - система контролю версій та, відповідно, сервіс для організації зберігання коду, а також публікації статичних сторінок.\nRStudio Desktop - інтегроване середовище розробки (IDE) для мови R з відкритим кодом, що містить в собі редактор коду, консоль, планер, засоби візуалізації та можливості.\nVisual Studio Code - інтегроване середовище розробки (IDE) з відкритим кодом практично для усіх відомих технологій та мов програмування.\n\n\n\n\n\nБібілографічний опис bibtex:\n@book{yk-r-intro,\n  author       = {Юрій Клебан},\n  title        = {Вступ до програмування в R},\n  publisher    = {Zenodo},\n  year         = 2022,\n  doi          = {10.5281/zenodo.7251419},\n  url          = {https://doi.org/10.5281/zenodo.7251419}\n}"
  },
  {
    "objectID": "00-intro.html",
    "href": "00-intro.html",
    "title": "Вступ",
    "section": "",
    "text": "На даний час існує велика кількість мов програмування, що інтегруються у суспільні сфери діяльності людини та роботи технічних систем: біоінформатика, а також економіка та бізнес.\nОднією з мов програмування, що отримали широке поишення серед економістів-науковців, аналітиків та практиків математичного моделювання (machine learning) є мова програмування (R)(R Core Team 2020). Свою популярність ця мова програмування здобула завдяки простоті у використанні, доступності (безкоштовні як базові компоненти для написання коду, так і середовища розробки), розширюваності (кожен розробник має можливість створювати власні пакети та публікувати їх у відкритому доступі).\nОсновними задачами курсу “Вступ до прграмування в R” є ознайомлення студентів з базовми конструкціями мови програмування R, вивчення способів роботи з найпоширенішими типами даних,\n\n\n\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "01-what-is-r.html",
    "href": "01-what-is-r.html",
    "title": "\n1  Що таке R?\n",
    "section": "",
    "text": "Синтаксис мови програмування R є досить простим для вивчення та використання, а широкий набір готових пакетів дозволяє використати готові розробки для виіршення широкого спектру задач від статистичних обчислень до навчання нейронних мереж для розпізнавання/класифікації зображень.\nВажливо відмітити, що мова програмування R є безкоштовною (free) і має відкритий код (open source).\nR має ряд корисних властивостей, серед яких варто виділити:\n\nВізуалізація даних. Побудова різноманітих видів графіків, робота з мапами, широкий спектр бібліотек та налаштувань до них.\nПовторне використання коду. На відміну від електронних таблиць, що мають обмеження на кількість спостережень (наприклад, MS Excel), R дозволяє працювати з великими масивами даних та перезапускати обчислення у потрібний момент не створюючи додаткових копій даних.\nМашинне навчання. R дозволяє використати для побудови, навчання та тестування моделей, а також оптимізації гіперпараметрів та відбору факторів дуже велику кількість алгоритмів. Існують також спеціальні пакети, що об’єднують у собі усі описані функції та алгоритми, наприклад, caret та mlr.\nАвтоматизація. Написаний код та проєкти можна перетворити у готові до публікації та впровадження продукти (deployment) або використовувати напрацьовані алгоритми для швидкого вирішення схожих задач (pipeline).\n\nТакож можна виділити досить корисні фічі Розробка веб-застосунків та Звітність, адже, використовуючи спеціальні бібліотеки (shiny, shinydashboard, flexdashboard, rmarkdown, knitr тощо), результати виконаної роботи можна “оживити” або сформувати “на льоту” готові до презентації документи."
  },
  {
    "objectID": "02-r-history.html",
    "href": "02-r-history.html",
    "title": "\n2  Коротка історія мови R\n",
    "section": "",
    "text": "Влітку 1993 року двоє молодих новозеландських вчених анонсували свлю нову розробку, яку вони назвали R (є інформація, що буква “R” була обрана тому, що вона стоїть перед “S” у латинському алфавіті, тут є аналогія з мовою “C”, якій передувала мова “B”). За задумом авторів (Robert Gentelman та Ross Ihaka) це повинна була бути нова реалізація мови S, що відрізнялася від S-Plus деякими деталями, наприклад, роботою з локальними та глобальними змінними, пам’яттю тощо. Фактично було створено нову мову, що відгалуджується від S.\nПроект з самого початку розвивався досить повільно, але коли у команди розробників R з’явлися ресурси, в тому числі зручна системи створення розширень (пакетів), все більше аналітиків, статистиків, вчених, програмістів почало переходити з S-Plus на R. Коли були усунуті проблеми роботи з пам’яттю перших версій R, на цю мову почали переходити користувачі інших статистичних пакетів (SAS, Stata, SYSSTAT).\nКількість книг та публікацій у мережі Інтернет по роботі з R постійно зростає разом із зацікавленням молодих і вже досвідчених спеціалістів зі сфери ІТ темою науки про дані, машинним навчанням, аналітикою для бізнесу, охорони здоров’я тощо."
  },
  {
    "objectID": "03-r-environment.html",
    "href": "03-r-environment.html",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "",
    "text": "R є безкоштовним програмним забезпеченням, що розповсюджується за умовами GNU General Public License. Код, написаний на R компілюється та запускається на різних платформах: UNIX, Windows, MacOS (R Core Team 2020)."
  },
  {
    "objectID": "03-r-environment.html#завантаження-та-інсталяція-r",
    "href": "03-r-environment.html#завантаження-та-інсталяція-r",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.1 Завантаження та інсталяція R",
    "text": "3.1 Завантаження та інсталяція R\nДля завантаження актуальної версії R варто перейти на сайт проекту https://cran.r-project.org/.\nНа сайті обираємо завантаження R для потрібної операційної системи. У межах курсу ми вокристовуємо ОС Windows, проте на синтаксис мови програмування та процес написання коду це не впливає:\n\n\nРис. 3.1. Завантаження R. Вибір ОС\n\n\nУ наступному вікні клікаємо на install R for the first time:\n\n\nРис. 3.2. Завантаження R. Перша інсталяція\n\n\nДалі обираємо Download R 4.X.X for Windows, де 4.X.X версія R, яка може бути відмінною на момент вивчення курсу:\n\n\nРис. 3.3. Завантаження R. Завантаження версії для ОС\n\n\nПісля завантаження файлу інсталяції потрібно його запустити. Зазвичай завантажений файл можна побачити у лівому нижному кутку браузера або у розділі “Завантаження” Вашого браузера. Наприклад, у браузері Google Chrome знайти цей пункт меню так:\n\n\nРис. 3.4. Завантаження R. Розділ \"Завантаження\" у Google Chrome"
  },
  {
    "objectID": "03-r-environment.html#перший-запуск-r-gui",
    "href": "03-r-environment.html#перший-запуск-r-gui",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.2 Перший запуск R GUI\n",
    "text": "3.2 Перший запуск R GUI\n\nЗа замовчуванням під час інсталяції R у ОС Windows пропонується шлях C:\\Program Files\\R\\R-4.X.X.\nДля запуску R GUI (стандартного графічного інтерфейсу для роботи з R) потрібно зайти у папку bin\\x64 (або i386, якщо у Вас 32-х розрядна ОС) та запустити файл Rgui.exe.\nВигляд вікна R GUI зображено нижче:\n\n\nРис. 3.5. Вигляд головного вікна RGui\n\n\n\n\n\n\n\n\nNote\n\n\n\nGUI (Graphical User Interface) - набір візуальних компонентів для інтерактивної взаємодії користувача з програмним забезпеченням.\n\n\nУ вікні R Console можна вводити команди/інструкції R, що будуть виконуватися:\nРезультати виконання команд зберігаються у памяті програми і можуть бути використані у наступних блоках коду:\n\n\nРис. 3.6. Вигляд консолі для команд RGui\n\n\nСередовище R GUI має широкий спектр функцій і дозволяє написати будь-якого рівня складності проекти на R, проте він є лише базовою графічною обгорткою для R. Розглянемо інші зручніші середовища для написання R-коду."
  },
  {
    "objectID": "03-r-environment.html#поняття-робочого-простору",
    "href": "03-r-environment.html#поняття-робочого-простору",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.3 Поняття робочого простору",
    "text": "3.3 Поняття робочого простору\nУ процесі виконання коду створені об’єкти/змінні та функції зберігаються у поточній сесії. У R є можливість переглянути список збережних елментів, видалити усі або окремі, зберегти стан поточної сесії диск та завантажити його пізніше, щоб не проходти усі етапи виконання коду повторно (інколи дуже складний код може виконувати досить довго і збереження проміжних результатів може бути хорошим рішенням).\nДля прикладу створимо дві змінні var1, var2 та виведемо на консоль їх значення:\n\nvar1 <- 10\nvar2 <- sqrt(15)\nvar1\n\n[1] 10\n\nvar2\n\n[1] 3.872983\n\n\nДля того аби переглянути список змінних у поточній сесії варто скористатися ls():\n\nls()\n\n[1] \"var1\" \"var2\"\n\n\nЯкщо виникає потреба очистити робочий простір і звільними пам’ять використовується команда rm(). Так, щоб очистити усі змінні можна скористатися rm(list = ls()), якщо ж Ви хочете видалити якусь одну/дві змінних, то просто вкажіть імена:\n\nrm(list = c(\"var1\"))\nls()\n\n[1] \"var2\"\n\n\nТаким чином, після виконання коду вище, залишиться лише змінна var2.\nЗберігання образу (image) робочого простору на диск здійснюється за допомогою команди save.image(\"шлях до файлу.RData\"), а його зчитування за допомогою load(\"шлях до файлу.RData\").\nКод збереження даних:\n\n# Clear workspace\nrm(list = ls())\n\n# Declare variables\na <- 10\nb <- a + 15\n\n# Save image to file\nsave.image(\"tmp.RData\")\n\nКод читання та виведення даних:\n\n# Clear workspace\nrm(list = ls())\n\n# load image to file\nload(\"tmp.RData\")\n\nprint(a)\n\n[1] 10\n\nprint(b)\n\n[1] 25\n\n\nУ прикладі 2 не створюєть жодного параметра, проте вони збережні у файлі сесії.\nДля того аби зберегти та зчитати окремий об’єкт, а не всі елементи сесії у R є спеціальний формат .RDS, який реалізовується методами saveRDS(об'єкт, file=\"шлях_файлу.rds\") та readRDS(file=\"шлях_файлу.rds\")."
  },
  {
    "objectID": "03-r-environment.html#поняття-робочого-каталогу",
    "href": "03-r-environment.html#поняття-робочого-каталогу",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.4 Поняття робочого каталогу",
    "text": "3.4 Поняття робочого каталогу\nРобота в будь-якому середовищі передбачає зв’язок із поточним каталогом, відносно якого будуються шляхи до файлів. Звичайно можна писати завжди повний шлях до файла, проте такий підхід є досить негнучким і під час перенесення коду між ПК створює чимало проблем розробникам.\nДля визначення базового каталогу R в поточній сесії використовують команду getwd(). Якщо Ви користуєтеся RStudio та створили проєкт, то цей каталог буде відповідати повному шляху до папки проєкту:\n\ngetwd()\n\n[1] \"E:/Repos/OA_2023/intro-to-r-source\"\n\n\nДля того аби змінити поточний робочий каталог використовують команду setwd(шлях). Після запуску цієї команди функцій getwd() буде вказутивати уже на нову адресу/шлях.\n\n\n\n\n\n\nImportant\n\n\n\nВарто знати та вміти будувати абсолютні та відносні шляхи до каталогів та файлів, ці знання корисні для роботи з усіма мовами програмування та більшістю ПЗ для роботи з даними.\n\n\nДля запису шляху у ОС Windows можна скористатися 2-ма способами:\n\n\n/ - слеш, записується як один знак;\n\n\\\\ - бекслеш, записується як два знаки.\n\nУ прикладі нижче обидва шляхи ведуть до тієї ж папки (drive - буква диска):\nsetwd(\"drive:/folder1/folder2/\")\nsetwd(\"drive:\\\\folder1\\\\folder2\\\\\")\nДля перегляду інформації про наявні каталоги та файли у поточній робочій папці можна скористатися командою dir() або list.files():\n\ndir()\n\n [1] \"_language-ua.yml\"            \"_quarto.yml\"                \n [3] \"00-intro.html\"               \"00-intro.qmd\"               \n [5] \"01-what-is-r.html\"           \"01-what-is-r.qmd\"           \n [7] \"02-r-history.html\"           \"02-r-history.qmd\"           \n [9] \"03-r-environment.qmd\"        \"03-r-environment.rmarkdown\" \n[11] \"03-r-environment_files\"      \"04-r-help.qmd\"              \n[13] \"05-r-packages.qmd\"           \"06-r-input-output.qmd\"      \n[15] \"07-r-variables.qmd\"          \"08-r-basic-types.qmd\"       \n[17] \"09-r-operators.qmd\"          \"10-r-conditions-if-else.qmd\"\n[19] \"11-r-loops.qmd\"              \"12-userful-math.qmd\"        \n[21] \"13-r-functions.qmd\"          \"14-r-vectors.qmd\"           \n[23] \"15-r-data.frames.qmd\"        \"16-r-lists.qmd\"             \n[25] \"commands\"                    \"css\"                        \n[27] \"demo.qmd\"                    \"docs\"                       \n[29] \"identity\"                    \"img\"                        \n[31] \"index.html\"                  \"index.log\"                  \n[33] \"index.qmd\"                   \"index.tex\"                  \n[35] \"index_files\"                 \"intro-to-r-source.Rproj\"    \n[37] \"references.bib\"              \"references.qmd\"             \n[39] \"site_libs\"                   \"solved-tasks.qmd\"           \n[41] \"summary.qmd\"                 \"tasks.qmd\"                  \n[43] \"tmp.RData\"                  \n\nlist.files()\n\n [1] \"_language-ua.yml\"            \"_quarto.yml\"                \n [3] \"00-intro.html\"               \"00-intro.qmd\"               \n [5] \"01-what-is-r.html\"           \"01-what-is-r.qmd\"           \n [7] \"02-r-history.html\"           \"02-r-history.qmd\"           \n [9] \"03-r-environment.qmd\"        \"03-r-environment.rmarkdown\" \n[11] \"03-r-environment_files\"      \"04-r-help.qmd\"              \n[13] \"05-r-packages.qmd\"           \"06-r-input-output.qmd\"      \n[15] \"07-r-variables.qmd\"          \"08-r-basic-types.qmd\"       \n[17] \"09-r-operators.qmd\"          \"10-r-conditions-if-else.qmd\"\n[19] \"11-r-loops.qmd\"              \"12-userful-math.qmd\"        \n[21] \"13-r-functions.qmd\"          \"14-r-vectors.qmd\"           \n[23] \"15-r-data.frames.qmd\"        \"16-r-lists.qmd\"             \n[25] \"commands\"                    \"css\"                        \n[27] \"demo.qmd\"                    \"docs\"                       \n[29] \"identity\"                    \"img\"                        \n[31] \"index.html\"                  \"index.log\"                  \n[33] \"index.qmd\"                   \"index.tex\"                  \n[35] \"index_files\"                 \"intro-to-r-source.Rproj\"    \n[37] \"references.bib\"              \"references.qmd\"             \n[39] \"site_libs\"                   \"solved-tasks.qmd\"           \n[41] \"summary.qmd\"                 \"tasks.qmd\"                  \n[43] \"tmp.RData\""
  },
  {
    "objectID": "03-r-environment.html#робота-з-rstudio",
    "href": "03-r-environment.html#робота-з-rstudio",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.5 Робота з RStudio\n",
    "text": "3.5 Робота з RStudio\n\n\n3.5.1 Завантаження та інсталяція RStudio Desktop\n\nRStudio - це інтегроване середовище розробки для R. Воно включає у себе консоль, підсвічування синтаксису (підказки), прямий запуск коду, інструменти для візуалізації графіків, html-коду, історію виконаних команд, відлагоджування коду, управління робочими просторами, підтримка різних видів розмітки та багато іншого. RStudio має версію з відкритим кодом та комерційну версію для Windows, Linux та Mac, а також веб-версію для серверів на Linux RStudio Server та RStudio Server Pro (RStudio Official Website 2021).\n\n\n\n\n\n\nNote\n\n\n\nIDE (integrated development environment) - комплексне програмне рішення для розробки програмного забезпечення. Зазвичай, складається з редактора початкового коду, інструментів для автоматизації складання та відлагодження програм. Більшість сучасних середовищ розробки мають можливість автодоповнення коду. Wikipedia\n\n\nЗавантажити продукти можна з сайту https://rstudio.com. Щоб знайти середовище, яке ми будемо використовувати під час вивчення курсу варто виконати наступні кроки:\n\nУ головному меню сайту обрати Products > RStudio.\nЗнаходимо на сторінці кнопку для завантаження програми RStudio Desktop версії Open Source та натискаємо DOWNLOAD RSTUDIO DESKTOP:\n\n\n\nРис. 3.7. Вибір версії RStudio Desktop\n\n\n\nДалі обираємо завантаження безкоштовної версії RStudio Desktop з наданого переліку:\n\n\n\nРис. 3.8. Завантаження RStudio Desktop\n\n\nПісля завантаження запускаємо інсталятор RStudio. Особливих кроків у цьому процесі немає.\nПісля запуску IDE RStudio зазвичай складається з 3-х або 4-х блоків: * Файл, з яким працювали останнім (зліва зверху). * Консоль для введення коду та виведення результатів (зліва знизу). * Змінні середовища (Environment) (справа зверху) + Історія команд (History), Зєднання з зовнішніми ресурсами даних, наприклад, бази даних (Connections), навчальна інструкція (Tutorial). * Файли каталогу або проекту (Files), Інстальовані пакети (Packages), Допомога (Help), Візуалізація результатів (Plots, Viewer).\n\n\nРис. 3.9. Головне вікно RStudio Desktop\n\n\nДля першої демонстрації роботи виконаємо у консолі 2 рядки коду:\n\n\nРис. 3.10. Приклад написання коду в RStudio Desktop\n\n\nПерший рядок з кодом data <- c(3,7,1,6,3,4,5,4,2) створює у пам’яті колекцію чисел. Зверніть увагу, що у блоці Environments відобраюаться усі змінні, що уснують у поточному робочому просторі (про це буде далі).\nДругий рядок plot(data, type=\"l\") дозволяє побудувати простий лінійний графік (type=\"l\" - linear, \"p\" - point, help(plot) для деталей). Графіки, що “промальовуються” як картинки выдображаються у блоці Plots. Якщо ж графік має більш складну візуалізацію з інтерактивними елементами, що використовують уже засоби html/css/js, то він буде відображений у блоці View.\nЯкщо перемкнутися на вкладку History, то ми побачимо перелік раніше виконаних команд.\n\n\n\n\n\n\nNote\n\n\n\nДля швидкого “гортання” уже виконаних раніше команд на консолі (Console) можна скористатися клавішами Up/Down на клавіатурі: \n\n\n\n3.5.2 Створення першого проекту в RStudio\nНа відміну від R Gui в RStudio реалізовано концепцію проектів, що дозволяє організувати код та поєднати різні його частини у межах певного рішення.\nСтворимо наш перший проект.\nДля початку оберемо з верхнього меню пункт File > New Project. У вікні вибору способу створення проекту клікаємо New Directory. Такий спосіб передбачає, що жодного файлу проекту поки не існує або ми пізніше туди скопіюємо уже готовий код.\n\n\nРис. 3.11. RStudio Desktop. Новий проєкт\n\n\nНа наступному кроці обираємо New Project:\n\n\nРис. 3.12. RStudio Desktop. Новий проєкт. Тип проекту\n\n\nПісля кліку на Create Project буде створено папку за попередньо обраним шляхом. Для запуску проєкту або швидкого перемикання між проектами можна скористатися як пунктами головного меню, так і підменю проектів справа. Також відкрити проект можна запуском файлу *.Rproj у провіднику Windows.\n\n\nРис. 3.13. RStudio Desktop. Новий проєкт\n\n\nЩоб додати новий файл з кодом R потрібно обрати з головного меню File > New file > R Script або скористатися командою Ctrl+Shift+N. Новий файл буде створено з назвою Untitled[X], тому рекомендую одразу його зберегти, наприклад, як TestCode.R\nДля першого проекту розвяжемо наступну задачу:\n\nНаписати програму, що генерує вектор з 20-ти випадкових чисел у межах [1;5], обчислює середнє та суму чисел, а також виводить гістограму частоти кожного значення (скільки разів дане число повторюється у векторі).\n\nКод для генерації 20-ти випадкових чесел у діапазоні [1;5] матиме наступний вигляд:\n\nvtr <- sample(1:5, 20, replace=TRUE)\nvtr\n\n [1] 1 3 2 5 3 5 5 2 2 2 1 2 5 4 4 2 2 1 5 2\n\n\n\n\n\n\n\n\nImportant\n\n\n\nРезультати виконання на Вашому ПК будуть іншими, адже псевдогенератор випадкових чисел буде брати іншу “точку відліку” для генерування чисел. Рекомендую перегляду функцію set.seed(точка відліку - число).\n\n\nОбчислення та виведення на консоль інформації про суму та середнє значення:\n\nvtr_sum <- sum(vtr)\nvtr_mean <- mean(vtr)\n\nprint(paste0(\"Sum: \", vtr_sum))\n\n[1] \"Sum: 58\"\n\nprint(paste0(\"Mean: \", vtr_mean))\n\n[1] \"Mean: 2.9\"\n\n\nВиведемо гістограму:\n\nhist(vtr, breaks = 5)\n\n\n\nПриклад візуалізації гістрограми в R\n\n\n\n\nПримітка. Детальніше про параметри функції hist() можна почитати тут: https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/hist.\nОрієнтовний вигляд вікна RStudio після викоання усіх описаних вище операцій матиме настпуний вигляд:\n\n\nРис. 3.14. RStudio Desktop. Перегляд змінних\n\n\nВарто звернути увагу на виділений блок Environment, де можна переглянути усі доступні змінні, що є на даний момент у пам'яті. До цих параметрів можна звертатися у коді чи з консолі у будь, який момент. Детальну інформацію про робоче середовище розглянуто нижче."
  },
  {
    "objectID": "03-r-environment.html#робота-з-jupyter-notebook",
    "href": "03-r-environment.html#робота-з-jupyter-notebook",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.6 Робота з Jupyter Notebook\n",
    "text": "3.6 Робота з Jupyter Notebook\n\nНоутбуки стали зручним та поширеним інструментом для аналізу даних, а також послідовного викладення матеріалів чи результатів дослідження. Перевагою такого інструменту є перемішування коду, результатів його виконання та іншого текстового наповнення, що дозволяє сформувати “на льоту” готові до читання документи.\nВикористання ноутбуків у навчальному процесі дозволяє описати не лише теоретичний матеріал, але приклади коду, що будуть виконувати безпосередньо під час ознайомлення з лекцією. Також слухач курсу може відредагувати наявний код та перевірити результати його виконання.\nРозгялнемо процес інсталяції та запуску Anaconda (середовище з відкритим кодом для вирішення задач Data Science) та Jupyter Notebook на ПК.\nДля встановлення середовища Anaconda потрібно перейти на сайт проекту та завантажити індивідуальну версію продукту: https://www.anaconda.com/products/individual (Anaconda. The World’s Most Popular Data Science Platform 2021).\n_*Примітка. Усі операції у даному курсі виконуються під операційну систему Windows 11 Education Edition_.\nПроцес інсталяції середовища Anaconda не відрізняється від стандарного покрокового вставнолення програм у Windows.\nПісля запуску Anaconda Navigator для початку потрібно створити нове середовище та налаштувати роботу R:\n\n\nРис. 3.15. Anaconda Navigator\n\n\nДля початку потрібно перейти на вкладку Environments та натиснути Create:\n\n\nРис. 3.16. Головне вікно Anaconda Navigator\n\n\nУ вікні, що відкрилося потрібно відмітити [x] вставновлення інструментів для роботи з R:\n\n\nРис. 3.17. Створення нового середовища на основі R у Anaconda Navigator\n\n\nПісля встановлення R-інструментів оптрібно переключитися на вкладку Home та робочий простір:\n\n\nРис. 3.18. Зміна середовища у Anaconda Navigator\n\n\nПісля завантаження робочого простору оберіть Launch для запуску Jupyter Notebook з переліку встановлених засобів. Jupyter Notebook буде запущено у браузері за замовчеванням Вашого ПК. Відкрити ноутбук можна обравши потрібний файл, а створити новий у меню справа New > Notebook > R:\n\n\nРис. 3.19. Створення нового Jupyter Notebook"
  },
  {
    "objectID": "03-r-environment.html#огляд-додаткових-ide-та-сервісів-для-роботи-з-r",
    "href": "03-r-environment.html#огляд-додаткових-ide-та-сервісів-для-роботи-з-r",
    "title": "\n3  Вcтановлення та налаштування R\n",
    "section": "\n3.7 Огляд додаткових IDE та сервісів для роботи з R",
    "text": "3.7 Огляд додаткових IDE та сервісів для роботи з R\nОкрім середовищ описаних вище існує ряд досить цікавих інструментів, що роблять досить зручною роботу з R-кодом. Розглянемо ці інструменти.\nVisual Studio Code - безкоштовний редактор коду від Microsoft, орієнтовний на велику кількість мов програмування та фреймворків (Visual Studio Code 2021). Серед інших іструментів у VS Code доступні також розширення для роботи з R:\n\n\nРис. 3.20. Вікно середовища Visual Studio Code\n\n\nVisual Studio Community Edition - безкоштовне середовище розробки від компаній Microsoft. VS створено з самого початку для розробки під платформу .NET та мови програмування C#, VB.NET, F# тощо, але з часом отримало багато розширень, що дозволяють у тому числі, працювати і з проектами в R (Visual Studio Community Edition 2021).\nGoogle Collab - онлайн сервіс для роботи з ноутбуками для Data Science від компанії Google (Google Colaboratory 2021):\n\n\nРис. 3.21. Вікно середовища Google Collab\n\n\nПримітка. Код у прикладі вище написаний на Python.\nkaggle.com - сервіс для змагань з Data Science та Machine Learning. Окрім переліку змагань, наборів даних сервіс має досить зручні ноутбуки.\n\n\nРис. 3.22. kaggle.com\n\n\nЗагалом сервісів та середовищ для розробки в R існує досить багато і їх кількість зростає, але це не впливає на принципи написання коду та роботу з даними.\n\n\n\n\nAnaconda. The World’s Most Popular Data Science Platform. 2021. 206 379 Broadway Ave., Suite 310 New York, NY 10013, USA: Anaconda Inc. https://www.anaconda.com/.\n\n\nGoogle Colaboratory. 2021. Google LLC. https://colab.research.google.com/.\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/.\n\n\nRStudio Official Website. 2021. 250 Northern Ave, Boston, MA 02210: RStudio, PBC. https://rstudio.com/.\n\n\nVisual Studio Code. 2021. Microsoft. https://code.visualstudio.com/.\n\n\nVisual Studio Community Edition. 2021. Microsoft. https://visualstudio.microsoft.com/."
  },
  {
    "objectID": "04-r-help.html",
    "href": "04-r-help.html",
    "title": "\n4  Документація та допомога\n",
    "section": "",
    "text": "# Get help for intersect() function\nhelp(intersect)\nЯкщо є потреба отримати інформацію про пакет скористайтеся:\nhelp(package = \"stats\")\n\n\n\n\n\n\nNote\n\n\n\nДетальну документацію по роботі з пакетами Ви можете знайти тут:\n\nhttps://cran.r-project.org/web/packages/available_packages_by_name.html\nhttps://www.rdocumentation.org/\nhttps://rdrr.io/r/\n\n\n\nРозглянемо для прикладу візуалізацію інформації про функцію mean(), що використовується для знаходження середнього значення:\nhelp(mean)\n\n\nРис. 4.1. Скріншот інформації про функцію mean() з пакету base(R Core Team (2020))\n\n\nОтримана інформація дозволить визначити як правильно викликати функцію, які параметри вона приймає та що вони означають. Наявність прикладів виклику функції такод полегшить роботу з написання коду.\n\n\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "05-r-packages.html",
    "href": "05-r-packages.html",
    "title": "\n5  Робота з пакетами\n",
    "section": "",
    "text": "Своєю популярністю R завдячує, у тому числі, і можливості швидко реалізувати досить складні дослідження за допомогою наборів уже готових функції. Такі функції обєднуються у пакети та публікуються вченими, досліджниками та розробниками зі всього світу.\nПакети в R - організовані набори методів та класів для виконання вузького набору задач під час програмування на R. Вони містять як функції так і опис способів їх використання, а чтакож дані для відтворення прикладів коду.\nПакети можуть бути завантажені з офіційного сайту проекту cran.r-project.org / (R Core Team 2020) або інших джерел (dev-версії є доступні на github).\nЗавантаження пакетів у R можна здійснювати як з локального диска, так і з серверів у мережі Інтернет.\nДля встановлення пакету використовується команда install.packages():\ninstall.packages(\"fun\")\nДля підключення пакету та його використання варто скористатися функцією library():\npackageDescription(\"fun\")\nhelp(package = \"fun\")\n\n\n\n\n\n\nNote\n\n\n\nДуже рекомендую почитати детальніше про пакети у статті на DataCamp: R Packages: A Beginner’s Guide."
  },
  {
    "objectID": "05-r-packages.html#робота-з-пакетами-в-rstudio",
    "href": "05-r-packages.html#робота-з-пакетами-в-rstudio",
    "title": "\n5  Робота з пакетами\n",
    "section": "\n5.2 Робота з пакетами в RStudio\n",
    "text": "5.2 Робота з пакетами в RStudio\n\nРобота з пакетами в RStudio організована досить зручно і дозволяє швидко переглянути інформацію про пакет та функції, які він дозволяє використати.\nДля інсталяції та оновлення пакетів можна скористатися меню Tools:\n\n\nРис. 5.1. Меню інсталяції пакетів у RStudio Desktop\n\n\nПісля вибору Install Packages... відкриється вікно, де можна обрати як джерело інсталяції пакету так і сам пакет з переліку, ввівши кілька перших букв його назви:\n\n\nРис. 5.2. Вибір пакету для інсталяції у RStudio Desktop\n\n\nRStudio дозволяє також переглянути інстальовані пакети/бібліотеки, розроблені іншими користувачами та завантажені у пам’ять (“галочка” навпроти назви пакету):\n\n\nРис. 5.3. Перегляд інстальованих пакетів у RStudio Desktop\n\n\nДоступ до функцій та інших елементів пакету можна здійснювати використавши запис назва_пакету::назва_функції() без підключення бібліотеки за допомогою library():\n\n\nРис. 5.4. Приклад використання пакету fun у RStudio Desktop\n\n\nКористувачі можуть не тільки завантажувати існуючі пакети, але і створювати власні та роботи їх доступними для дослідників зі всього світу."
  },
  {
    "objectID": "05-r-packages.html#завдання-для-студентів",
    "href": "05-r-packages.html#завдання-для-студентів",
    "title": "\n5  Робота з пакетами\n",
    "section": "Завдання для студентів",
    "text": "Завдання для студентів\nВстановіть пакет fun, використовуючи функцію install.packages() та перегляньте його документацію за допомогою help().\nДля прикладу, спробуйте пройти якийсь з тестів.\nНижче наведено приклад роботи з функцією alzheimer_test() з пакету fun:\n\nlibrary(fun)\nalzheimer_test(\n  char1 = c(\"9\", \"O\", \"M\", \"I\", \"F\", \"D\"),\n  char2 = c(\"6\", \"C\", \"N\", \"T\", \"E\", \"O\"),\n  nr = 10,\n  nc = 30))\n\n\n\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/."
  },
  {
    "objectID": "06-r-input-output.html",
    "href": "06-r-input-output.html",
    "title": "\n6  Введення-виведення даних\n",
    "section": "",
    "text": "Читання даних з консолі R можна здійснювати за допомогою функцій scan() та readline().\nreadline() - читає рядок з консолі та записує його в змінну. Розглянемо приклад:\n\ntext <- readline(prompt = \"Text to ask user input: \") # prompt a text to view\n\nФункція scan() зчитує дані з консолі та зберігає їх у векторі. Приклад використання у RStudio Desktop:\n data <- scan() 1: 12 5 3: 2 4:\n> z [1] 12 5 2"
  },
  {
    "objectID": "06-r-input-output.html#виведення-даних",
    "href": "06-r-input-output.html#виведення-даних",
    "title": "\n6  Введення-виведення даних\n",
    "section": "\n6.2 Виведення даних",
    "text": "6.2 Виведення даних\nДля виведення даних у RStudio можна просто скористатися назвою змінної або використати функцію print().\n\nx <- 5\ny <- 10\nprint(x + y)\n\n[1] 15\n\n\nЩе однією корисною функцією є cat(). Вона використовується для виведення об’єктів, конкантенації тексту та значень змінних. Приклад:\n\ncat(\"Some text\", 1, \"more text\")\n\nSome text 1 more text\n\n\nУ цьому посібнику часто використовуються також функції paste() та paste0() для конкантенації тексту та значень змінних перед виведенням. Синтаксис функції paste() настпуний paste(..., sep = \" \", collapse = NULL). Параметр sep визначає роздільник між елементами, а collapse - роздільник між рядками. Приклад:\n\npaste(\"file\", \"number\", \"32\") # default separator is space \" \"\n\n[1] \"file number 32\"\n\n\n\npaste(\"file\", \"number\", \"32\", sep = \"_\") # separator underline \"_\"\n\n[1] \"file_number_32\"\n\n\nУсі параметри перед сепаратором (sep) повинні бути розділені комами.\nФункція paste0(…, collapse = NULL) працює так само, але не використовує сепаратор між елементами. Приклад:\n\nprint(paste0(\"file\", \"number\", \"32\"))\n\n[1] \"filenumber32\""
  },
  {
    "objectID": "07-r-variables.html",
    "href": "07-r-variables.html",
    "title": "\n7  Оголошення та ініціалізація змінних\n",
    "section": "",
    "text": "Базовим поняттям практично усіх мов програмування є змінна. Змінна дозволяє записати значення або об’єкт та назвати його для подальшого доступу, зміни, видалення по імені.\nНаприклад, присвоєння змінній my_variable значення 10 записується так: my_variable <- 5 або my_variable = 5.\nОперація надання змінній певного значення у програмуванні називається присвоєнням.\n\n\n\n\n\n\nImportant\n\n\n\nВажливо! Зверніть увагу, що присвоєння (<-, =) та рівність (==) це різні поняття. Оператор == здіснює перевірку співпадіння значення двох змінних/об’єктів та повертає результат у вигляді логічного значення TRUE (якщо значення рівні) або FALSE (якщо значення не рівні).\n\n\nЗнак <- не є часто використовуваним у різних мовах програмування, зазвичай для присвоєння користуються =. Проте в R освновним способом засобом початкової ініціалізації змінних є <-.\nТакож у програмуванні на R використовуються оператори присвоєння <<-, ->, ->>. Про них можна прочитати за лыками нижче.\n\n\n\n\n\n\nTip\n\n\n\nРекомендую почитати про різницю між операторами присвоєння у R <- та = тут:\n\n\nWhy do we use arrow as an assignment operator? (Colin FAY).\n\nDifference between assignment operators in R (Ren Kun).\n\nAssignment Operators.\n\n\n\nПриклад:\n\nx <- 45\ny <- 10\nz <- x + y # z = 45 + 10\nz\n\n[1] 55\n\n\nРозберемо приклад, описаний вище:\n\nУ першому рядку оголошується змінна x і їй присвоюється значення 45.\nУ другому рядку оголошується змінна y і їй присвоюється значення 10.\nУ третьому рядку оголошується змінна z і їй присвоюється значення суми x + y. # у R використовується як коментар коду, текст написаний після нього ігнорується.\n\nУ четвертому рядку відбувається виведення на консоль змінної z."
  },
  {
    "objectID": "07-r-variables.html#правила-іменування-змінних",
    "href": "07-r-variables.html#правила-іменування-змінних",
    "title": "\n7  Оголошення та ініціалізація змінних\n",
    "section": "\n7.2 Правила іменування змінних",
    "text": "7.2 Правила іменування змінних\nЄ кілька основних правил іменування змінних у R: 1. Ім’я змінної може складатися з букв [a-z, A-z], цифр [0-9], крапки . та нижнього підкреслювання _. 2. Ім’я змінної повинно починатися з букви або крапки. Якщо воно починається з крапки, то наступним символом повинна бути буква. 3. Не можна використовувати зарезервовані ключові слова мови програмування для іменування змінних, наприклад, TRUE/FALSE.\nІм’я змінної не може містити пробіл (space). Якщо є потреба назвати об’єкт кількома словами, то їх зазвичай розділяють підкресленням _ або крапкою .. Наприклад, змінну можна назвати my_variable_name або my.variable.name. Назва myVariableName (camel case) теж буде коректно сприйнята мовою програмування R, проте такий запис тут вживається не часто.\nПриклад коректного іменування змінних: total, zminna, Sum, .length_of_something, Number123, x_1.\nПриклад неправильного іменування змінних: tot@l, 5x_1, _variable, FALSE, .0ne."
  },
  {
    "objectID": "08-r-basic-types.html",
    "href": "08-r-basic-types.html",
    "title": "\n8  Базові типи даних R\n",
    "section": "",
    "text": "Усі мови програмування мають власну типізацію даних з якими працюють. Тип даних - це набір властивостей певних об’єктів та операцій, що можна з ними виконувати. Так, наприклад, з цілими числами можна виконувати арифметичні операції додавання, віднімання та інші. Набори символів (простими словами текст) зазвичай можуть використовуватися для пошуку у них елементів, редагування (шляхом видалення частини існуючого або додавання нового тексту), склеювання та розділення на частини.\nУ R, на відміну від строго типізованих мов програмування, тип даних визначається на основі поточного значення елемента і може змінюватися у процесі виконання.\nРозгялнемо приклад коду з мови програмування C# (мова родом із C/Java):\nint a = 10;\na = \"some text\";\nПодібний код у C# передбачає створення нової змінної a типу int (integer - ціле число), а потім відбувається присвоєння для a текстового фрагмента (тип string у С#). Такий код не буде запущено і виникне помилка компіляції.\nРозглянемо приклад коду з R:\n\na <- 10\na <- \"some text\"\na\n\n[1] \"some text\"\n\n\nТакий код виконається і на консоль буде виведено some text, адже у 1 першому рядку було присвоєно ціле число, у другому - текст. Таким чином R має динамічну типізацію, що дозволяє у ту ж саму змінну записати значення різних типів. Проте варто пам’ятати, що попереднє значення буде втрачено.\nДо базових типів даних у R варто віднести:\n\nЧисла з дробовою частиною (decimal numbers), як наприклад, 4.0, 15.214, що називаються numeric(s).\nНатуральні числа (natural numbers), як наприклад, 4, 15, що називаються integer(s).\nЛогічні значення (boolean values), тобто TRUE та FALSE (які також можна скорочено записувати T та F), що називаються logical.\nТекст або рядки (string values), як наприклад, \"Hello\", \"12 is number\", що називаються character(s).\n\nОголосимо для прикладу три змінні: my_numeric - число, my_character - текст, my_logical - логічне значення.\nmy_numeric <- 5\nmy_character <- \"universe\"\nmy_logical <- FALSE\nЗамінимо значення my_character <- \"5\" та спробуємо знайти суму значень:\n\nmy_character <- \"5\"\nmy_sum <- my_numeric + my_character\n\nУ результаті виклання даного коду ми отримаємо помилку, адже значення 5 та \"5\" є елементами різних типів даних, перевіримо типи за допомогю функції class():\n\nclass(5)\n\n[1] \"numeric\"\n\nclass(\"5\")\n\n[1] \"character\"\n\n\nВиконання коду class(5) показує нам, що 5є значенням числового типу даних numeric, а class(\"5\") відповідає тексту character, тому арифметична операція додавання між цими значеннями неможлива."
  },
  {
    "objectID": "08-r-basic-types.html#перевірка-та-привдення-типів-даних",
    "href": "08-r-basic-types.html#перевірка-та-привдення-типів-даних",
    "title": "\n8  Базові типи даних R\n",
    "section": "\n8.2 Перевірка та привдення типів даних",
    "text": "8.2 Перевірка та привдення типів даних\nУ випадку коли тип даних потрібно визначити у процесі виконання програми/коду та перетворити значення використовується приведння типів даних.\nПриведення типів даних - операція перетворення значення з одного типу даних в інший. Важливо памятати, що не завжди приведення типів даних може бути здійснено. Так, наприклад, значення \"5\" (character) можна досить просто привести до 5 (numeric), проте \"five\" не буде зрозумілим для інтерпритатора.\nДля перевірки належності елемента до певного типу даних використовують спеціальну функцію is.назва_типу(значення). Ця функція повертає TRUE, якщо елемент належить даному типу і FALSE, якщо не належить.\nРозглянемо приклад:\n\nmy_numeric <- 5\nmy_character <- \"five\"\nmy_logical <- FALSE\n\nis.numeric(my_numeric)\n\n[1] TRUE\n\nis.character(my_numeric)\n\n[1] FALSE\n\n\nДля перетворення типу даних можна скористатися функцією as.назва_типу(значення). У результаті виконання функції буде повернуто значення потрібного типу або пусте значення NA, якщо таке приведення не є можливим:\n\na <- 5\nb <- \"10\"\nc <- \"10, 20\"\nas.numeric(b)\n\n[1] 10\n\nas.numeric(c)\n\nWarning: NAs introduced by coercion\n\n\n[1] NA\n\n\nРезультат виконання функцій можна записувати у змінні і використовувати у наступних обчисленнях:\n\na <- 5\nb <- \"10\"\nb <- as.numeric(b)\na + b\n\n[1] 15\n\n\n\nnumber <- as.integer(54)\ntypeof(number)\n\n[1] \"integer\"\n\nclass(number)\n\n[1] \"integer\"\n\n\nПовний перелік типів та методів перевірки і приведення їх типів ображений нижче:\n\nБазові типи даних R, методи перевірки та приведення\n\nНазва типу\nМетод перевірки типу\nМетод приведення типу\n\n\n\nArray\nis.array()\nas.array()\n\n\nCharacter\nis.character()\nas.character()\n\n\nComplex\nis.complex()\nas.complex()\n\n\nDataframe\nis.data.frame()\nas.data.frame()\n\n\nDouble\nis.double()\nas.double()\n\n\nFactor\nis.factor()\nas.factor()\n\n\nList\nis.list()\nas.list()\n\n\nLogical\nis.logical()\nas.logical()\n\n\nMatrix\nis.matrix()\nas.matrix()\n\n\nNumeric\nis.numeric()\nas.numeric()\n\n\nRaw\nis.raw()\nas.raw()\n\n\nTime series (ts)\nis.ts()\nas.ts()\n\n\nVector\nis.vector()\nas.vector()"
  },
  {
    "objectID": "08-r-basic-types.html#приклади-розвязання-завдань",
    "href": "08-r-basic-types.html#приклади-розвязання-завдань",
    "title": "\n8  Базові типи даних R\n",
    "section": "\n8.3 Приклади розв’язання завдань",
    "text": "8.3 Приклади розв’язання завдань\n\n8.3.1 Завдання 1. Сума введених чисел\nЗнайти суму введених з клавіатури чисел. Для введення інформації скористатися функцією readline(prompt = \"Text\").\nРозв’язання:\n\n# works on console and notebook / run this code line by line\na <- readline(prompt = \"Enter A:\") # read a\nb <- readline(prompt = \"Enter B:\") # read b\n\na <- as.numeric(a) # convert character to numeric\nb <- as.numeric(b) # convert character to numeric\n\nsum <- a + b\nsum\n\nРезультат виконання:\nEnter A: 10\nEnter B: 45\n55"
  },
  {
    "objectID": "09-r-operators.html",
    "href": "09-r-operators.html",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "",
    "text": "R можна використовувати як звичайни калькулятор.\nРозглянемо набір звичних арифметичних операторів, що відомі з початкової школи:\n\nДодавання: +.\nВіднімання: -.\nДілення: /.\nМноження: *.\n\nА також більш складні оператори:\n\nПіднесення до степеня: ^ (вводиться з клавіатури як Shift+6 на ENG-розкладці клавіатури).\nОстача від ділення (ще може називатися “ділення по модулю”): %% (вводиться з клавіатури як Shift+5).\nДілення націло: %/%.\n\nРозглянемо приклад додавання чисел:\n\n5 + 10\n\n[1] 15\n\n\n\n5 + 4 + 15\n\n[1] 24\n\n5 + 53 + 343\n\n[1] 401\n\n\n\n(5 + 8) + (4 + 9)\n\n[1] 26\n\n\n\n\n\n\n\n\nNote\n\n\n\nПримітка. Використання “круглих” дужок у прогрмуванні виразах має пріоритет аналогічний до загальноприйнятих у математиці.\n\n\nРозглянемо приклад віднімання чисел:\n\n47 - 21\n\n[1] 26\n\n\n\n15 - (10 - 25)\n\n[1] 30\n\n\n\n\n\n\n\n\nNote\n\n\n\nПримітка. Заміна знаків до/в “дужках” тут працює так само як працювала у школі :)\n\n\nПриклади множення чисел:\n\n5 * 3\n\n[1] 15\n\n\n\n5 * (2 + 5)\n\n[1] 35\n\n\nПриклади ділення чисел:\n\n12 / 2\n\n[1] 6\n\n\n\n(4 + 7) / 3\n\n[1] 3.666667\n\n\nПіднесення до степеня за допомогю оператора ^ є досить простим. Так, наприклад, 3^2 (у математиці записується як \\(3^2\\)) дорівнює 9, а 2^3 - це 2*2*2 і дорівнює 8.\n\n5^2\n\n[1] 25\n\n\n\n(1+3)^3 + 100 \n\n[1] 164\n\n\nОстача від ділення дозволяє знайти залишок одного числа від ділення на інше число.\nНаприклад, остача від ділення націло 5 на 2 дорівнює 1, бо 2 * 2 (=4) + 1 = 5\n\n28 %% 7\n\n[1] 0\n\n\n\n17 %% 5\n\n[1] 2\n\n\nПримітка. Пробіли між цифрами та операторами можна не лишати, це робиться для зручності візуального сприйняття коду.\nДілння націло залишає лише цілу частину від ідленнядвох чисел:\n\n28 %/% 7\n\n[1] 4"
  },
  {
    "objectID": "09-r-operators.html#оператори-відношення",
    "href": "09-r-operators.html#оператори-відношення",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "\n9.2 Оператори відношення",
    "text": "9.2 Оператори відношення\nОператори відношення відповідають за порівнняння двох об’єктів між собою та повертають значення логічного типу TRUE, якщо результат істинний та FALSE, якщо результат хибний.\nПерелік операторів відношення:\n\nБільше або дорівнює >=.\nМенше <.\nМенше або дорівнює <=.\nДорівнює ==.\nНе дорівнює !=\n\n\nДля демонстрації принципів роботи операторів відношення оголосимо 3 змінні a, b та c.\n\na <- 12\nb <- 5\nc <- 7\n\nРозгялнемо кілька прикладів використання описаних вище операторів.\nОператори, що відповідають за первірку на “більше/менше”:\n\na > b\n\n[1] TRUE\n\nb + c < a\n\n[1] FALSE\n\nb + c <= a\n\n[1] TRUE\n\n\nОператори, що відповідають за перевірку на “рівність/нерівність”:\n\na != b\n\n[1] TRUE\n\na == b + c\n\n[1] TRUE\n\nb == c\n\n[1] FALSE"
  },
  {
    "objectID": "09-r-operators.html#chapter233",
    "href": "09-r-operators.html#chapter233",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "\n9.3 Логічні оператори",
    "text": "9.3 Логічні оператори\nДо логічних операторів у R відносяться:\n\n\n& - І (амперсант, Shift-7) - виконання усіх умов одночасно.\n\n| - АБО (вертикальна риска, Shift+\\) - виконання однієї із умов.\n\n! - НЕ (знак оклику, Shift+1) - заперечення.\n\n\n\n\n\n\n\nImportant\n\n\n\nЗверніть увагу, що у R існують також і оператори && та ||. Це також логічні оператори І та АБО. Проте їх відмінність полягає у тому, що “розширені” оператори порівнюють лише перші елементи векторів, у той час як “скорочені” усі елементи:\n\nx <- c(5, 8, 10)\ny <- c(3, 2, 5)\n\nprint(x)\n\n[1]  5  8 10\n\nprint(y)\n\n[1] 3 2 5\n\nx > 5 & y < 7\n\n[1] FALSE  TRUE  TRUE\n\n\n\nx > 5 && y < 7\n\n[1] FALSE\n\n\n\n\nВажливо розуміти відмінності між цими операторами вміти використовувати результи їх роботи. Для початку варто розглянути таблицю істинності:\n\nТаблиця істинності логічних операторів\n\nA\nB\nОператор І\n\nОператор АБО\n\nЗаперечення A (не A)\n\n\n\nFALSE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nFALSE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nTRUE\nFALSE\n\n\nTRUE\nTRUE\nTRUE\nTRUE\nFALSE\n\n\n\nПриклади використання логічних операторів зображені нижче.\nОператор І (and):\n\n\n\n\na <- 12\nb <- 7\n\na > 10 & b < 10\n\n[1] TRUE\n\na > 10 & b > 10\n\n[1] FALSE\n\na < 10 & b < 10\n\n[1] FALSE\n\na < 10 & b > 10\n\n[1] FALSE\n\n\nОператор АБО (or):\n\na > 10 & b < 10\n\n[1] TRUE\n\na > 10 | b > 10\n\n[1] TRUE\n\na < 10 | b < 10\n\n[1] TRUE"
  },
  {
    "objectID": "09-r-operators.html#завдання",
    "href": "09-r-operators.html#завдання",
    "title": "\n9  Арифметичні та логічні оператори\n",
    "section": "Завдання",
    "text": "Завдання\nЗавдання 1\nЯким буде результат виконання наступних команд?\n\na <- 10\nb <- 4\n\na %% b > 0 # what is result \n\n[1] TRUE\n\n\nРезультат:\nTRUE\nПояснення: \\(a\\) %% \\(b = 2\\), бо остача від ділення \\(10\\) на \\(4\\) рівна \\(2\\), а \\(2 > 0 = true\\).\nЗавдання 2\nЯким буде результат виконання наступних команд?\nПідзавдання 1:\n\na <- 7\nb <- 12\nc <- a - b %% 2\n\nc\n\nРезультат:\n7\nПідзавдання 2:\n\nc > 0 & b > a\n\nРезультат:\nTRUE\nПідзавдання 3:\n\nc < 0 | b > a\n\nРезультат:\nTRUE"
  },
  {
    "objectID": "10-r-conditions-if-else.html",
    "href": "10-r-conditions-if-else.html",
    "title": "\n10  Розгалуження\n",
    "section": "",
    "text": "Якщо є потреба перевірити у коді програми виконання якоїсь умови та за її результатами перейти до одного із блоків виконання зазвичай використовують оператор if-else. Загальний вигляд формату використання оператора if-else:\n if (умова) {\n    #інструкція\n  }\n  else {\n    #інструкція\n  }\nВираз умова повинен повертати результат у вигляді елемента логічного типу. Тобто, умова може бути або true, або false.\nЯкщо умова рівна true, то виконається інструкція (або код) записана у дужках після if. Якщо ж умова рівна false, то виконається інструкція записана у дужках після else.\n\n\n\n\n\n\nNote\n\n\n\nСимвол # перед кодом означає коментар, тобто код, який не бачитиме інтепретатор мови програмування.\n\n\nЯкщо після if або else тільки одна інструкція (можна ототожнити з один рядком коду), то «фігурні» дужки {} не є обов’язковими.\nКонструкції if-else можуть вкладеними одна в одну без обмежень по глибині. Проте дуже глибокої вкладеності варто уникати, адже це ускладнює читання та розуміння коду програми.\nif (умова1)\n{\n  if (умова2)\n  {\n    #інструкція\n  }\n}\n\n\n\n\n\n\nNote\n\n\n\nif є обов’язковим і повинно існувати у всіх подібних конструкціях, у той же час else – необов’язковий.\n\n\nТакож конструкція if-else може мати структуру дерева із багатьма розгалуженнями. Така структура зазвичай записується як if-else-if:\nif (умова1)\n  { #код }\n  else if (умова2)\n      { #код }\n      else if (умова3)\n          { #код }\n          else { #код }\nВирази обчислюються зверху-вниз. Якщо один із виразів (умова) отримає істинний результат (true), то програмний код, пов’язаний із цією гілкою розгалуження виконається, а всі інші гілки будуть пропущені. Якщо ж не виконається жодна з умов, то буде запущено код всередині останньої інструкції else (у цьому випадку else теж не обов’язковий).\nРозгялнемо приклади використання конструкції if-else. Код нижче дозволяє перевірити, яке з двох цілих чисел є більшим:\n\na <- 10\nb <- 5\n\nif(a > b) {\n    print(\"A > B\")\n} else if (b > a){\n    print(\"B > A\")\n} else {\n    print(\"A equals B\")\n}\n\n[1] \"A > B\""
  },
  {
    "objectID": "10-r-conditions-if-else.html#тернарний-оператор",
    "href": "10-r-conditions-if-else.html#тернарний-оператор",
    "title": "\n10  Розгалуження\n",
    "section": "\n10.2 Тернарний оператор",
    "text": "10.2 Тернарний оператор\nТернарний оператор – це спосіб запису умовного виразу в один рядок. Він використовується, коли потрібно присвоїти значення змінній в залежності від умови. Синтаксис тернарного оператора у R відрізняється від інших мов програмування (класично це умова ? вираз_якщо_true : вираз_якщо_false).\nОператор розгалуження if-else у R може повертати та записувати значення у змінну:\n\nvalue <- 10\nx <- if(value %% 2 == 0) \"even\" else \"odd\"\nx\n\n[1] \"even\"\n\n\nПроте сильною стороною R є саме робота з векторами. Тому, якщо потрібно виконати умовну перевірку для кожного елемента вектора, то краще використати функцію ifelse(). Синтаксис виклику:\nifelse(condition, a, b)\nде condition – вектор умов, a – вектор значень, які будуть повернуті, якщо умова condition істинна, b – вектор значень, які будуть повернуті, якщо умова condition не істинна.\nРозглянемо приклад. Потрібно створити вектор, який містить значення 1 для значень >= 0 та 0 для значень < 0 на основі наявного вектора x:\n\n x <- c(-6, 2, -3, 4, 5)\n binary_vector <- ifelse(x > 0, 1, 0)\n print(binary_vector)\n\n[1] 0 1 0 1 1\n\n\nТакож оператор ifelse можна використовувати і для заміни значень вектора. Наприклад, потрібно замінити всі значення Yes/No на 1/0:\n\nx <- c(\"Yes\", \"No\", \"Yes\", \"Yes\", \"No\")\nprint(x)\n\n[1] \"Yes\" \"No\"  \"Yes\" \"Yes\" \"No\" \n\nx <- ifelse(x == \"Yes\", 1, 0)\nprint(x)\n\n[1] 1 0 1 1 0"
  },
  {
    "objectID": "10-r-conditions-if-else.html#приклади-розвязання-завдань",
    "href": "10-r-conditions-if-else.html#приклади-розвязання-завдань",
    "title": "\n10  Розгалуження\n",
    "section": "Приклади розв’язання завдань",
    "text": "Приклади розв’язання завдань\nЗавдання 1. Парні/непарні числа\nНапишіть програму, що виводить консоль інформацію про те число парне чи ні. Значення \\(0\\) потрібно потрібно також перевірити і вивести у разі його введення \"ZERO\".\nРозв’язання\n\na <- readline(prompt = \"Enter A:\") # read a\na <- as.numeric(a) \nremainder <- a %% 2\nif(a == 0) {\n  print(\"ZERO\")  \n} else if(remainder == 0) {\n  print(\"EVEN\")\n} else if (remainder == 1) {\n  print(\"ODD\")\n}\n\nРезультат виконання коду:\nEnter A: 2\n[1] \"EVEN\""
  },
  {
    "objectID": "11-r-loops.html",
    "href": "11-r-loops.html",
    "title": "\n11  Цикли у R\n",
    "section": "",
    "text": "Цикли у програмуванні використовуються для виконання повторюваних операцій. В R є три типи циклів: for(“R for Loop,” n.d.), while(“R for Loop,” n.d.) та repeat(sabir, n.d.)."
  },
  {
    "objectID": "11-r-loops.html#цикл-for",
    "href": "11-r-loops.html#цикл-for",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.1 Цикл for\n",
    "text": "11.1 Цикл for\n\nЦикл for у R використовується для повторюваних операцій над елементами вектора. Ми раніше уже використовували вектори для фнших прикладів:\n\nx <- c(2, 4, 5, 7, 9, 11, 14)\nx\n\n[1]  2  4  5  7  9 11 14\n\n\nСинтаксис циклу for виглядає наступним чином:\nfor (value in sequence) { \n  code\n}\nДе value - це змінна, яка буде використовуватись для доступу до елементів вектора sequence. code - це код, який буде виконуватись для кожного елемента вектора sequence.\nДля прикладу, давайте знайдемо кількість непарних елементів вектора x:\n\n# створюємо змінну count та присвоюємо їй значення 0\neven_count <- 0                   \n# створюємо вектор x\nx <- c(2, 4, 5, 7, 9, 11, 14)     \n\nfor (i in x) {\n  # якщо елемент i не парний\n  if (i %% 2 != 0) {     \n    # збільшуємо значення even_count на 1         \n    even_count <- even_count + 1  \n    # виводимо значення i та even_count\n    print(paste(\"i: \", i, \" | even_count: \", even_count)) \n  }\n}\n\n[1] \"i:  5  | even_count:  1\"\n[1] \"i:  7  | even_count:  2\"\n[1] \"i:  9  | even_count:  3\"\n[1] \"i:  11  | even_count:  4\"\n\nprint(even_count)\n\n[1] 4\n\n\nУ прикладі вище, цикл for виконався 7 разів, бо саме стльіки значень у векторі x. На кожній ітерації циклу змінні i отримує нове значення з вектора x.\nТакож цикл for можна використовувати для роботи з індексами елементів вектора (або іншої колекції). Розвязати попередній приклад можна також так:\n\n# створюємо змінну count та присвоюємо їй значення 0\neven_count <- 0                   \n# створюємо вектор x\nx <- c(2, 4, 5, 7, 9, 11, 14)     \n\nfor (i in 1:length(x)) {\n  # якщо елемент **x[i]** не парний\n  if (x[i] %% 2 != 0) { \n    # збільшуємо значення even_count на 1             \n    even_count <- even_count + 1    \n    # виводимо значення i та even_count\n    print(paste(\"i: \", i, \" | even_count: \", even_count)) \n  }\n}\n\n[1] \"i:  3  | even_count:  1\"\n[1] \"i:  4  | even_count:  2\"\n[1] \"i:  5  | even_count:  3\"\n[1] \"i:  6  | even_count:  4\"\n\nprint(even_count)\n\n[1] 4\n\n\n\n\n\n\n\n\nTip\n\n\n\nФункція length() повертає довжину вектора/послідовності."
  },
  {
    "objectID": "11-r-loops.html#цикл-while",
    "href": "11-r-loops.html#цикл-while",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.2 Цикл while\n",
    "text": "11.2 Цикл while\n\nЦикл while виконується поки вказана умова є істинною, а синтаксис виглядає наступним чином:\nwhile (condition) {\n  code\n}\nде condition - це умова, яка повинна бути істинною, а code - це код, який буде виконуватись поки умова condition є істинною.\nНаприклад, виведемо на консоль усі парні числа від 1 до 10:\n\ni <- 1\n\nwhile(i <= 10) {\n  # збільшуємо значення i на 1 на кожній ітерації циклу\n  i <- i + 1 \n  # перевіряємо i на парність\n  if (i %% 2 == 0) {\n    print(i)\n  }\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n\n\nВикористовуючи цикл while Ви моежете виконувати"
  },
  {
    "objectID": "11-r-loops.html#команди-break-та-next",
    "href": "11-r-loops.html#команди-break-та-next",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.3 Команди break та next\n",
    "text": "11.3 Команди break та next\n\nКоманди break та next дозволяють виконувати певні дії в циклі.\nТак, break зупиняє виконання поточного циклу, а next переходить на виконання наступної ітерації циклу, на виконуючи код після неї.\nРозглянемо наступний приклад: потрібно вивести на консоль усі парні числа з поданого вектора x <- c(4, 6, 7, 1, -4, 0, 6, -8), але при цьому пропускати від’ємні числа, а при знаходженні 0 зупинити виконання циклу.\n\nx <- c(4, 6, 7, 1, -4, 0, 6, -8)\n\nfor(i in x) {\n  # якщо i < 0, то переходимо на наступну ітерацію циклу\n  if(i < 0) \n    next\n  # якщо i == 0, то зупиняємо виконання циклу та виводимо повідомлення\n  if(i == 0) {\n    print(\"ZERO!!!\")\n    break\n  }\n  # якщо i парне, то виводимо його на консоль\n  if(i %% 2 == 0) \n    print(i)\n}\n\n[1] 4\n[1] 6\n[1] \"ZERO!!!\""
  },
  {
    "objectID": "11-r-loops.html#цикл-repeat",
    "href": "11-r-loops.html#цикл-repeat",
    "title": "\n11  Цикли у R\n",
    "section": "\n11.4 Цикл repeat\n",
    "text": "11.4 Цикл repeat\n\nЦикл repeat на відміну від for та while зупиняється лише коли виконано команду break та не має жодних умов виходу з нього. Синтаксис виглядає наступним чином:\nrepeat {\n  code\n  if(condition) {\n    break\n  }\n}\nПриклад використання циклу repeat:\n\ni <- 1\nrepeat {\n  print(i)\n  i <- i + 1\n  if(i > 10) {\n    break\n  }\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\nУ прикладі вище ми вивели на консоль усі числа від 1 до 10."
  },
  {
    "objectID": "11-r-loops.html#приклади-розвязання-завдань",
    "href": "11-r-loops.html#приклади-розвязання-завдань",
    "title": "\n11  Цикли у R\n",
    "section": "Приклади розв’язання завдань",
    "text": "Приклади розв’язання завдань\nЗавдання 1. —\n\n\n\n\n“R for Loop.” n.d. W3Schools. https://www.w3schools.com/r/r_for_loop.asp.\n\n\nsabir. n.d. “R Repeat Loop.” R-Bloggers.com. https://www.r-bloggers.com/2022/07/r-repeat-loop/."
  },
  {
    "objectID": "12-userful-math.html",
    "href": "12-userful-math.html",
    "title": "\n12  Корисні математичні функції\n",
    "section": "",
    "text": "Функції у програмуванні мають ім'я/назву та () (круглі дужки). Виклик функції зазвичай має вигляд function_name(params)."
  },
  {
    "objectID": "12-userful-math.html#заокруглення-чисел",
    "href": "12-userful-math.html#заокруглення-чисел",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.1 Заокруглення чисел",
    "text": "12.1 Заокруглення чисел\nУ цьому розділі описано роботу функцій: round(), ceiling(), floor(), trunc(), signif().\nЯк ми знаємо з математики, що заокруглення чисел буває “вверх”, “вниз” або відносно деякого значення, зазвичай пов’язаного із цифрою 5 (3.6 заокруглюємо до цілого як \\(4\\), а \\(3.2\\) як \\(3\\), ввжаючи \\(3.5\\) межею.\n\n\n\n\n\n\nWarning\n\n\n\nУвага! Заокрулення чисел у програмуванні може призводити до помилок у результатах обчислень. Для задач бізнесу, фінансів або технічних процесів мінімальні відхилення можуть призводити до викривлених результатів або збоїв у системах.\n\n\n\n12.1.1 Функція round()\n\n\nПримітка. Тут і надалі функції будуть позначатися як назва() (назва і “круглі” дужки).\n\nДля заокруглення дійних чисел (з дробовою частиною) за правилом <0.5 & >=0.5 (не знаю як називається науково) використовується функція round(x, y), де x - число, y - точність (кількість знаків після коми/крапки). Наприклад:\n\nround(3.557, 2)\n\n[1] 3.56\n\nround(3.241, 2)\n\n[1] 3.24\n\nround(-3.557, 2)\n\n[1] -3.56\n\nround(-3.241, 2)\n\n[1] -3.24\n\n\nТакож можна використати round(x) з одним параметром, тоді заокруглення відбудеться до цілої частини, наприклад:\n\nround(124.345)\n\n[1] 124\n\n\n\n12.1.2 Функція floor()\n\nДля заокруглення до найближчого меншого цілого числа слід скористатися функцією floor():\n\nfloor(3.557)\n\n[1] 3\n\nfloor(3.241)\n\n[1] 3\n\nfloor(-3.557)\n\n[1] -4\n\nfloor(-3.241)\n\n[1] -4\n\n\n\n12.1.3 Функція ceiling()\n\nДля заокруглення до найближчого більшого цілого числа слід скористатися функцією ceiling():\n\nceiling(3.557)\n\n[1] 4\n\nceiling(3.241)\n\n[1] 4\n\nceiling(-3.557)\n\n[1] -3\n\nceiling(-3.241)\n\n[1] -3\n\n\n\n12.1.4 Функція trunc()\n\nФункція trunc() у R використовується для отримання найбільшого цілого числа, яке більше або рівне x. Простими словами це означає, що для чисел менших 0 (x < 0) trunc() працює як celing(), а для чисел більших нуля x > 0, як floor():\n\nx <- 5.34\nprint(paste(\"trunc:\", trunc(x), \"celing:\", ceiling(x), \"floor:\", floor(x), sep = \" \"))\n\n[1] \"trunc: 5 celing: 6 floor: 5\"\n\nx <- x * -1\nprint(paste(\"trunc:\", trunc(x), \"celing:\", ceiling(x), \"floor:\", floor(x), sep = \" \"))\n\n[1] \"trunc: -5 celing: -5 floor: -6\"\n\n\n\n12.1.5 Функція signif()\n\nІнколи виникає потреба заокруглити не десяткову частину числа, а десятки, сотні, тисячі і так далі. Розглядемо варіант, коли у нас є велике число \\(11 547 741.3\\) і нам потрібно коротко його записати як \\(11.5 млн\\). Для таких задач можна використати функцію signif(x,y), де x - число, яке потрібно заокруглити до певного порядку, y - порядок заокруглення (рахувати від початку). Наприклад:\n\nbig_number <- 11547741.3\nrounded_big_number <- signif(big_number,3)\nrounded_big_number\n\n[1] 11500000\n\nrounded_big_number / 1000000\n\n[1] 11.5"
  },
  {
    "objectID": "12-userful-math.html#послідовності-чисел",
    "href": "12-userful-math.html#послідовності-чисел",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.2 Послідовності чисел",
    "text": "12.2 Послідовності чисел\nПослідовності у програмуванні на R це вектори, які містять набір чисел. Найпростіший спосіб створити послідовність у R це використання оператора “двокрапка” :, наприклад:\n\nseq <- 1:4\nseq\n\n[1] 1 2 3 4\n\nclass(seq)\n\n[1] \"integer\"\n\n\n\n12.2.1 Функція seq()\n\nФункція seq() використовується для створення послідовностей чисел. Ця функція приймає наступні аргументи:\n\n\nfrom - початок послідовності\n\nto - кінець послідовності\n\nby - крок послідовності\n\nlength.out - довжина послідовності\n\nРозглянемо кілька прикладів використання функції seq().\nВиведемо числа від \\(1\\) до \\(10\\):\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nВиведемо числа від \\(0\\) до \\(10\\) з кроком \\(2.5\\):\n\nseq(0, 10, by = 2.5)\n\n[1]  0.0  2.5  5.0  7.5 10.0\n\n\nВиведемо та покажемо на графіку 50 чисел від \\(0\\) до \\(10\\) (крок у такому випадку обчислюється функцією самостійно):\n\ns <- seq(0, 10, length=50)\nprint(s)\n\n [1]  0.0000000  0.2040816  0.4081633  0.6122449  0.8163265  1.0204082\n [7]  1.2244898  1.4285714  1.6326531  1.8367347  2.0408163  2.2448980\n[13]  2.4489796  2.6530612  2.8571429  3.0612245  3.2653061  3.4693878\n[19]  3.6734694  3.8775510  4.0816327  4.2857143  4.4897959  4.6938776\n[25]  4.8979592  5.1020408  5.3061224  5.5102041  5.7142857  5.9183673\n[31]  6.1224490  6.3265306  6.5306122  6.7346939  6.9387755  7.1428571\n[37]  7.3469388  7.5510204  7.7551020  7.9591837  8.1632653  8.3673469\n[43]  8.5714286  8.7755102  8.9795918  9.1836735  9.3877551  9.5918367\n[49]  9.7959184 10.0000000\n\nplot(seq(0, 10), seq(0, 50, length=11), type=\"l\", col=\"blue\")\n\n\n\n\n\n12.2.2 Функція rep()\n\nФункція rep() також використовується для створення послідовностей чисел, що повторюються. Ця функція приймає наступні аргументи:\n\n\nx - послідовність, що повторюється\n\ntimes - кількість повторень\n\neach - кількість повторень кожного елемента\n\nСинтаксис виклику:\nrep(x = <вектор>, \n    times = <кількість повторень ветора>, \n    each = <кількість повторень кожного елемента>)\nПриклади використання та результаи виконна коду подано нижче.\n\n# 123 повторюється 2 рази\nrep(1:3, times = 2)   \n\n[1] 1 2 3 1 2 3\n\n\n\n# вектор x повторюється 2 рази\nx <- c(5, 2, 7)\nrep(x, times = 2)   \n\n[1] 5 2 7 5 2 7\n\n\n\n# 1 повторюється 2 рази\n# 2 повторюється 1 раз\n# 3 повторюється 4 рази\nrep(1:3, times=c(2,1,4))  \n\n[1] 1 1 2 3 3 3 3\n\n\n\n# кожен елемент повторюється 2 рази\nrep(1:3, each=2) \n\n[1] 1 1 2 2 3 3\n\n\n\nx <- c(1,3,5)\nrep(x, each = 3, times = 2)\n\n [1] 1 1 1 3 3 3 5 5 5 1 1 1 3 3 3 5 5 5"
  },
  {
    "objectID": "12-userful-math.html#генерація-псевдовипадкових-чисел",
    "href": "12-userful-math.html#генерація-псевдовипадкових-чисел",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.3 Генерація псевдовипадкових чисел",
    "text": "12.3 Генерація псевдовипадкових чисел\nR має вбудовані функції для генерації псевдовипадкових чисел: runif(), sample().\n\n12.3.1 Функція runif()\n\nrunif() генерує послідовність випадкових чисел з рівномірним розподілом на відрізку \\([min, max]\\). Ця функція приймає наступні аргументи:\n\n\nn - кількість чисел;\n\nmin - мінімальне значення (за замовчуванням \\(0\\));\n\nmax - максимальне значення (за замовчуванням \\(1\\)).\n\nНаприклад, згенеруємо \\(5\\) випадкових значень на відрізку \\([min, max]\\):\n\nrunif(5)\n\n[1] 0.02720446 0.76234159 0.04443445 0.47192009 0.65925193\n\n\nВиведемо графік з \\(1000\\) випадкових знань на відрізку \\([0, 1]\\):\n\nx <- runif(1000)\nplot(x)\n\n\n\n1000 випадкових знань на відрізку [0, 1] з використанням функції runif()\n\n\n\n\n\n12.3.2 Функція sample()\n\nФункція sample() дозволяє вибрати числа випадковим чином із деякого набору (вектора).\nСинтаксис виклику:\nsample(x = <вектор>, \n       size = <кількість випадкових значень>, \n       replace = <TRUE/FALSE, >, \n       prob = <вектор з ймовірностями>)\nПрипустимо у нас є деякий вектор x:\n\nx <- 10:20\nprint(x)\n\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\nДля того аби виьрати одне із значень вектора x випадковим чином, використаємо функцію sample():\n\nsample(x)\n\n [1] 13 18 16 19 14 10 11 20 17 12 15\n\n\nЯкщо ми хочемо вибрати декілька значень вектора x випадковим чином, то використаємо аргумент size:\n\nsample(x, size = 4)\n\n[1] 11 13 19 14\n\nsample(x, size = 4)\n\n[1] 20 12 19 13\n\n\nЗверніть увагу, що у такому випадку усі значення завжди будуть різними у межах одного вибору.\nУ випадку, якщо потрібно вибрати значення з повтореннями, то використаємо аргумент replace:\n\nsample(x, size = 15, replace = TRUE)\n\n [1] 18 20 17 14 18 13 12 17 16 18 19 10 18 16 19\n\n\nЯкщо потрібно вибрати значення з деякими ймовірностями, то використаємо аргумент prob:\n\nt <- sample(c(1,2), size = 1000, replace = T, prob = c(80, 20))\nhist(t, breaks = 2, col = c('blue', 'green'))\n\n\n\n\n\n12.3.3 Поняття бази випадкових чисел\nТаким чином ми отримаємо \\(800\\) значень \\(1\\) та \\(200\\) значень \\(2\\)."
  },
  {
    "objectID": "12-userful-math.html#інші-математичні-функції-та-константи-r",
    "href": "12-userful-math.html#інші-математичні-функції-та-константи-r",
    "title": "\n12  Корисні математичні функції\n",
    "section": "\n12.4 Інші математичні функції та константи R",
    "text": "12.4 Інші математичні функції та константи R\nОкрім описаного вище набору функцій R містить дуже велику кількість реалізованих функцій з різних сфер науки, бізнесу, техніки тощо. Прочитати про них можна з офіційної документації пакетів, у яких вони реалізовані та знайти за допомогою функції help() або ?name.\nДалі розглянемо перелік найпоширеніших функцій, що використовуються для розв’язання навчальних задач під час вивчення основ програмування.\n\nПопулярні математичні функції в R\n\n\nФункція\nПризначення, опис\n\n\n\nlog(x)\nЛогарифм числа x за основою e\n\n\n\nlog(x,n)\nЛогарифм числа x за основою n\n\n\n\nexp(x)\n\ne у степені x\n\n\n\nsqrt(x)\nКорінь квадратний числа x\n\n\n\nfactorial(x)\nФакторіал числа x\n\n\n\nabs(x)\nМодуль числа x\n\n\n\n\nТакож у R доступні ряд тригонометричних функцій, які вивчалися у школі і не тільки, серед них cos(x), sin(x), tan(x), а також acos(x), asin(x), atan(x), acosh(x), asinh(x), atanh(x).\nДетальніше про кожну з них можна почитати у документації за допомогою кодманди help(function)."
  },
  {
    "objectID": "12-userful-math.html#приклади-розвязання-завдань",
    "href": "12-userful-math.html#приклади-розвязання-завдань",
    "title": "\n12  Корисні математичні функції\n",
    "section": "Приклади розв’язання завдань",
    "text": "Приклади розв’язання завдань\nЗавдання 1. Генерація випадкових чисел\nЗгенеруйте \\(1000\\) випадкових чисел у діапазоні \\([0,1]\\). Заокругліть їх до десятих (“2 знаки після коми/крапки”). Побудуйте графік за допомогою функції plot().\nРозв’язання\n\nx <- runif(1000)\nx <- round(x, 1)\nplot(x)"
  },
  {
    "objectID": "13-r-functions.html",
    "href": "13-r-functions.html",
    "title": "\n13  Створення функцій\n",
    "section": "",
    "text": "Усі мови програмування окрім набору вбудованих функцій також дозволяють створювати власні функції, що інколи жє наобхідним для вирішення задачі, а інколи спрощує написаний код та полегшує його тестування.\nУсі функції мають кілька спільних характеристик:\n\nФункція - це блок коду, що виконується при її виклику по імені.\nФункція може приймати аргументи, які використовуються в коді функції.\nФункція може повертати значення, яке може бути використано в коді, де функція була викликана.\n\nСтворення фукнцій у R відбувається з використанням ключового слова function, а синтаксис має вигляд:\n\nmy_func <- function() {\n  print(\"this is my first function\")\n}\n\nmy_func()\n\n[1] \"this is my first function\"\n\n\nУ рядках 1-3 створюється функція my_func, яка не приймає аргументів, але виконує дію виводу тексту \"this is my first function\" на екран. У рядку 5 функція викликається.\nУвага. Виконання функції відбувається у момент виклику, а не у момент створення.\nУ прикладі вище my_func є імям функції, а my_func() - її виликом."
  },
  {
    "objectID": "13-r-functions.html#передача-аргументів-та-повернення-значень",
    "href": "13-r-functions.html#передача-аргументів-та-повернення-значень",
    "title": "\n13  Створення функцій\n",
    "section": "\n13.2 Передача аргументів та повернення значень",
    "text": "13.2 Передача аргументів та повернення значень\nФункції також можуть приймати аргументи. Ви можете додати стільки аргументів, скільки вам потрібно, розділяючи їх комами.\nНаприклад, створимо функцію для конвретації валюти з гривні у долари:\n\nuah_to_usd <- function(uah) {\n  usd_rate <- 40\n  usd_amount <- uah / usd_rate\n  print(usd_amount)\n}\n\nuah_to_usd(200)\n\n[1] 5\n\n\nУ прикладі вище ми вивели значення прямо з функції, проте частіше виникає потреба повернути значення з функції, щоб використати його далі. Для цього використовується ключове слово return. Перепишемо нашу функцію:\n\nuah_to_usd <- function(uah) {\n  usd_rate <- 40\n  usd_amount <- uah / usd_rate\n  return(usd_amount)\n}\n\ntotal_usd <- uah_to_usd(200)\nprint(paste(\"Total USD:\", total_usd))\n\n[1] \"Total USD: 5\"\n\n\nНасправді у R можна не використовувати return, а просто використовувати останнє значення, яке буде обчислено в функції. Однак, це не є хорошою практикою, оскільки це може призвести до помилок, які важко знайти у коді програми:\nuah_to_usd <- function(uah) {\n  usd_rate <- 40\n  usd_amount <- uah / usd_rate\n  return(usd_amount)\n}"
  },
  {
    "objectID": "13-r-functions.html#аргументи-функції-за-замовчуванням",
    "href": "13-r-functions.html#аргументи-функції-за-замовчуванням",
    "title": "\n13  Створення функцій\n",
    "section": "\n13.3 Аргументи функції за замовчуванням",
    "text": "13.3 Аргументи функції за замовчуванням\nРозширимо нашу попереню функцію та будемо також передавати курс USD/UAH як параметр. Якщо курс не передано, то використовуємо курс за замовчуванням:\n\nuah_to_usd <- function(uah, usd_rate = 40) {\n  usd_amount <- uah / usd_rate\n  return(usd_amount)\n}\n\n# Буде використано курс за замовчуванням\nuah_to_usd(200)\n\n[1] 5\n\n# Буде використано курс 42.5\nuah_to_usd(200, 42.5)\n\n[1] 4.705882"
  },
  {
    "objectID": "13-r-functions.html#приклади-розвязання-завдань",
    "href": "13-r-functions.html#приклади-розвязання-завдань",
    "title": "\n13  Створення функцій\n",
    "section": "Приклади розв’язання завдань",
    "text": "Приклади розв’язання завдань\nЗавдання 1. Середнє значення\nНапишіть функцію, що обчислює середнє значення чисел у векторі та повертає його. Точність обчислень - \\(2\\) знаки після коми.\nПримітка. Під час розвязання задачі не можна користуватися жодними готовими вбудованими функціямию\nРозв’язання\n\naverage <- function(x) {\n  count <- 0\n  sum <- 0\n  for(i in x) {\n    count <- count + 1\n    sum <- sum + i\n  }\n  return(round(sum/count, 2))\n}\n\nvector <- c(5, 2, 7, 9, 2, 1)\n\naverage(vector)\n\n[1] 4.33\n\n\nЗавдання 2. Створення вектору із випадковими числами\nНаписати функцію, що генерує вектор випадкових чисел у вказаному діапазоні. Якщо діапазон користувачем не вказано, то генеруються значення у діапазоні від \\(0\\) до \\(100\\). Також варто врахувати, що випадкові числа можуть мати дробову частину. У такому випадку потрібно передати\nРозв’язання\n\nrandomNumbers <- function(n, min = 0, max = 100, intOnly = TRUE) {\n  if(intOnly) {\n    return(sample(min:max, n, replace = TRUE))\n  } else {\n    return(runif(n, min, max))\n  }\n}\n\nrandomNumbers(10, intOnly = F)\n\n [1]  8.220704 91.801853 17.024162 20.073679 81.753974 72.372942 86.226690\n [8] 87.079420  3.889626 28.759655\n\nrandomNumbers(10, 100, 200)\n\n [1] 156 131 118 108 180 195 108 161 122 155\n\n\nЗавдання 3. Депозитний калькулятор\nНапишіть функцію, що обчислює суму депозиту на кінець терміну вкладу. Функція повинна приймати наступні аргументи:\n\n\nP - сума депозиту у гривні.\n\nn - термін депозиту у місяцях.\n\nr - щомісячна відсоткова ставка за депозитом\nmonthly capitaliztion\n\nDuring caluculations print every month info in style: “Month: 1 / Total: 1010 / 10 EUR” Suppose I deposit 1000 (P) dollars in bank every month for 60 (n) months and bank pays me 1 (rate) percent per month as interest. Hence I can calculate the interest on each deposit as:\n\\(A = P*(1+\\frac{r}{n})^n\\)\nThe formula used is A = P(1+r/n) ^ n, where ‘A’ represents final amount procured, ‘P’ represents principal, ‘r’ represents annual interest rate, ‘n’ represents the number of times that interest has been compounded, ‘t’ represents the tenure."
  },
  {
    "objectID": "tasks.html#послідовності",
    "href": "tasks.html#послідовності",
    "title": "[-] Задачі для самостійної підготовки",
    "section": "Послідовності",
    "text": "Послідовності"
  },
  {
    "objectID": "tasks.html#функції",
    "href": "tasks.html#функції",
    "title": "[-] Задачі для самостійної підготовки",
    "section": "Функції",
    "text": "Функції"
  },
  {
    "objectID": "tasks.html#читаннязапис-даних",
    "href": "tasks.html#читаннязапис-даних",
    "title": "[-] Задачі для самостійної підготовки",
    "section": "Читання/запис даних",
    "text": "Читання/запис даних"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Список використаних джерел",
    "section": "",
    "text": "Anaconda. The World’s Most Popular Data Science Platform. 2021.\n206 379 Broadway Ave., Suite 310 New York, NY 10013, USA: Anaconda Inc.\nhttps://www.anaconda.com/.\n\n\nGoogle Colaboratory. 2021. Google LLC. https://colab.research.google.com/.\n\n\nR Core Team. 2020. R: A Language and Environment for Statistical\nComputing. Vienna, Austria: R Foundation for Statistical Computing.\nhttps://www.R-project.org/.\n\n\n“R for Loop.” n.d. W3Schools. https://www.w3schools.com/r/r_for_loop.asp.\n\n\nRStudio Official Website. 2021. 250 Northern Ave, Boston, MA\n02210: RStudio, PBC. https://rstudio.com/.\n\n\nsabir. n.d. “R Repeat Loop.” R-Bloggers.com. https://www.r-bloggers.com/2022/07/r-repeat-loop/.\n\n\nVisual Studio Code. 2021. Microsoft. https://code.visualstudio.com/.\n\n\nVisual Studio Community Edition. 2021. Microsoft. https://visualstudio.microsoft.com/."
  }
]